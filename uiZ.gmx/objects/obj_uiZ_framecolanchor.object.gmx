<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///#define uiZ
//#exclude
uiz_objinit()
draw=false;
color=c_white
sprite=spr_uiZ_framepulllinevertical
texturemode_horizontal=uiz_texturemode_fill
texturemode_vertical=uiz_texturemode_fill
spriteconnectionleft=spr_uiZ_framepulllineconnectionleft
spriteconnectionright=spr_uiZ_framepulllineconnectionright
spriteconnectiontop=spr_uiZ_framepulllineconnectiontop
spriteconnectionbottom=spr_uiZ_framepulllineconnectionbottom
frameBarThickness = .10
frameBarThicknessType = dp
iscover=0
fromx=0
fromy=0
tox=0
toy=0

marginl=0
marginr=0
margint=0
marginb=0
margincellw=0
margincellh=0
margin=1
automargins=true;
snaptoparent=1
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>frameat[0]=noone
isize[0]=0
hasBar[0]=false;
minSize[0]=0;
minSizeType[0]=px;
maxSize[0]=0;
maxSizeType[0]=px;
absorbPixelDiff[0]=0;
absorbPixelDiffTotal = 0;
thickness=15
overframebar=0
lastmouse=0
snaptomouse=0
snaptobar=0
stopsnap=0
mousesnappoint=0;
toleft = 0;
lastFixSize = 0;
forceFixSize = true;

uiz_frameset_fixThickness();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ds_exists(children,ds_type_list) then{ds_list_destroy(children)}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>kmouseover = uiz_mouse_isonobject_leftcheck(id);
uiz_frameset_colanchor_CalculateOverFrameBar();

if kmouseover==uiz_mousereleased {
    if snaptomouse = 1 then {
        stopsnap = 0
        snaptomouse = 0
        uiz_mouse_unfreeze();
        uiz_updater_unstep();
    }
}
if snaptomouse &gt; 0 then {

    if uiz_getmouse_x() &lt; 0 or uiz_getmouse_y() &lt; 0 or uiz_getmouse_x() &gt; global.screenpxwidth or uiz_getmouse_y() &gt; global.screenpxheight then {
        stopsnap = true;
    }

    if stopsnap then {
        mousediff = 0;
    } else {
        mousediff = - ((uiz_getmouse_x() - frameat[overframebar].rlx) - mousesnappoint);
    }
    lastmouse = uiz_getmouse_x();
    stopsnap = false;
    
    var bothWidth = frameat[snaptobar].width + frameat[snaptobar + 1].width;
    if maxSize[snaptobar+1] == 0 then {
        var du = 0;
    } else {
        var du = bothWidth - uiz_getposx_self(maxSize[snaptobar+1], maxSizeType[snaptobar+1]);
    }
    
    if maxSize[snaptobar] == 0 then {
        var dm = 0;
    } else {
        var dm = bothWidth - uiz_getposx_self(maxSize[snaptobar], maxSizeType[snaptobar]);
    }
    
    var thisMinSize = max(uiz_getposx_self(minSize[snaptobar], minSizeType[snaptobar]), du, 0*(isizetype[snaptobar]==xtra));
    var otherMinSize = max(uiz_getposx_self(minSize[snaptobar + 1], minSizeType[snaptobar + 1]), dm, 0*(isizetype[snaptobar + 1]==xtra));
    var thisMaxSize = bothWidth - otherMinSize;
    var otherMaxSize = bothWidth - thisMinSize;
    
    if thisMinSize &gt; thisMaxSize then{
        sdbm("[uiZ|WARNING] Frameset minimum and frame maximum sizes are incompatible with each other!");
        exit;
    }
    
    //fix isz
    isz[snaptobar] -= mousediff
    if isz[snaptobar] &lt; thisMinSize then{
        isz[snaptobar] = thisMinSize;
    }else if isz[snaptobar] &gt; thisMaxSize then{
        isz[snaptobar] = thisMaxSize;
    }
    isz[snaptobar + 1] += mousediff
    if isz[snaptobar + 1] &lt; otherMinSize then{
        isz[snaptobar + 1] = otherMinSize;
    }else if isz[snaptobar + 1] &gt; otherMaxSize then{
        isz[snaptobar + 1] = otherMaxSize;
    }
    
    var oldISizeThis = isize[snaptobar];
    
    switch (isizetype[snaptobar]) {
        case px:
            isize[snaptobar] -= mousediff
            if isize[snaptobar] &lt; thisMinSize then{
                isize[snaptobar] = thisMinSize;
                stopsnap = true;
            }else if isize[snaptobar] &gt; thisMaxSize then{
                isize[snaptobar] = thisMaxSize;
                stopsnap = true;
            }
            break;
        case fc:
            isize[snaptobar] = min(1 - 1 / width, max(1 / width, ((isize[snaptobar] * width) - mousediff) / width))
            if isize[snaptobar] &lt; thisMinSize / width then{
                isize[snaptobar] = thisMinSize / width;
                stopsnap = true;
            }else if isize[snaptobar] &gt; thisMaxSize / width then{
                isize[snaptobar] = thisMaxSize / width;
                stopsnap = true;
            }
            break;
        case dp:
            isize[snaptobar] -= mousediff / uiz_dp
            if isize[snaptobar] &lt; thisMinSize / uiz_dp then{
                isize[snaptobar] = thisMinSize / uiz_dp;
                stopsnap = true;
            }else if isize[snaptobar] &gt; thisMaxSize / uiz_dp then{
                isize[snaptobar] = thisMaxSize / uiz_dp;
                stopsnap = true;
            }
            break;
    }
    
    var oldISizeOther = isize[snaptobar + 1];
    
    switch (isizetype[snaptobar + 1]) {
        case px:
            isize[snaptobar + 1] += mousediff
            if isize[snaptobar + 1] &lt; otherMinSize then{
                isize[snaptobar + 1] = otherMinSize;
                stopsnap = true;
            }else if isize[snaptobar + 1] &gt; otherMaxSize then{
                isize[snaptobar + 1] = otherMaxSize;
                stopsnap = true;
            }
            break;
        case fc:
            isize[snaptobar + 1] = min(1 - 1 / width, max(1 / width, ((isize[snaptobar + 1] * width) + mousediff) / width))
            if isize[snaptobar + 1] &lt; otherMinSize / width then{
                isize[snaptobar + 1] = otherMinSize / width;
                stopsnap = true;
            }else if isize[snaptobar + 1] &gt; otherMaxSize / width then{
                isize[snaptobar + 1] = otherMaxSize / width;
                stopsnap = true;
            }
            break;
        case dp:
            isize[snaptobar + 1] += mousediff / uiz_dp
            if isize[snaptobar + 1] &lt; otherMinSize / uiz_dp then{
                isize[snaptobar + 1] = otherMinSize / uiz_dp;
                stopsnap = true;
            }else if isize[snaptobar + 1] &gt; otherMaxSize / uiz_dp then{
                isize[snaptobar + 1] = otherMaxSize / uiz_dp;
                stopsnap = true;
            }
            break;
    }
    
    if isizetype[snaptobar]==xtra then{
        if isizetype[snaptobar+1]==xtra then{
        //BOTH XTRA
            var startSize = floor(toleft / starsr);
        
            var newW = (frameat[snaptobar].width - mousediff);
            if newW &lt; thisMinSize then{
                newW = thisMinSize;
                stopsnap = true;
            }else if newW &gt; thisMaxSize then{
                newW = thisMaxSize;
                stopsnap = true;
            }
            
            var oldIsize = isize[snaptobar];
            var totISize = isize[snaptobar] + isize[snaptobar + 1];
            isize[snaptobar] = newW / startSize;
            isize[snaptobar + 1] -= (isize[snaptobar] - oldIsize)
            var newTotISize = isize[snaptobar] + isize[snaptobar + 1];
            
            //recalculate starsr to forgo rounding errors
            starsr = 0;
            for (var i = 0; i &lt; divisions; i++) {
                if isizetype[i]==xtra then{
                    starsr+=isize[i];
                }
            }
            
            uiz_frameset_fixAbsorbPixelDiff(0);
        }else{
        //LEFT FRAME ONLY XTRA
            switch (isizetype[snaptobar + 1]) {
                case px:
                    var toleftOffset = (isize[snaptobar + 1] - oldISizeOther)
                    break;
                case fc:
                    var toleftOffset = (isize[snaptobar + 1] - oldISizeOther)*width
                    break;
                case dp:
                    var toleftOffset = (isize[snaptobar + 1] - oldISizeOther)*uiz_dp
                    break;
            }
            //get total amount of xtra
            uiz_frameset_handleExtraOffset(toleftOffset, 0);
        }
    } else if isizetype[snaptobar+1]==xtra then{
        //RIGHT FRAME ONLY XTRA
        switch (isizetype[snaptobar]) {
            case px:
                var toleftOffset = (isize[snaptobar] - oldISizeThis)
                break;
            case fc:
                var toleftOffset = (isize[snaptobar] - oldISizeThis)*width
                break;
            case dp:
                var toleftOffset = (isize[snaptobar] - oldISizeThis)*uiz_dp
                break;
        }
        //get total amount of xtra
        uiz_frameset_handleExtraOffset(toleftOffset, 1);
    }
    
    uiz_framesetfixvertical(id);
    uiz_updater_FixViews();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_frameset_colanchor_CalculateOverFrameBar();

//update view
var x1 = frameat[overframebar].rlx;
var x2 = x1 + thickness;
var extendTop = 0;
var extendBottom = 0;
if parent.object_index = obj_uiZ_framerowanchor then {
    if inlistpos &gt; 0 and parent.hasBar[inlistpos - 1] then {
        extendTop = parent.thickness;
    }
    if inlistpos + 1 &lt; parent.divisions and parent.hasBar[inlistpos] then {
        extendBottom = parent.thickness;
    }
}
uiz_updater_FixViews_area_selfmarked(x1,ry-extendTop,x2,rly+extendBottom);

switch(kmouseover){
    case uiz_mousepressed:
        if snaptomouse = 0 and hasBar[overframebar] then {
            snaptomouse = 1
            snaptobar = overframebar;
            mousesnappoint = uiz_getmouse_x() - frameat[overframebar].rlx;
            global.mousefrozen = 1
            lastmouse = uiz_getmouse_x()
            uiz_mouse_freeze();
            uiz_updater_step();
        }
    break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_mouse_docheck()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if draw and uiz_cntn() then{
    var ux, uwidth, uy, uheight
    var h = 0//-thickness / 2;
    draw_set_alpha(alpha)
    draw_set_color(color)
    for (var i = 0; i &lt; divisions - 1; i++) {
        h += isz[i]
        if hasBar[i] then {
            uy = 0
            uheight = height
            //get the y of the frames

            ux = h
            uwidth = thickness
            if parent.object_index = obj_uiZ_framerowanchor then {
                var nwidth = uwidth
                var nheight = uheight
                var nrx = rx + ux
                //var nry=ry+uy
                if inlistpos &gt; 0 and parent.hasBar[inlistpos - 1] then {
                    var nry = ry + uy //+parent.thickness/2
                    if spriteconnectiontop != 0 then {
                        var simg;
                        if global.mouseover = id and overframebar = i then {
                            if kmouseover&gt;=uiz_mouseclick then {
                                simg = 2
                            } else {
                                simg = 1
                            }
                        } else {
                            if global.mouseover = parent.id and parent.overframebar = inlistpos - 1 then {
                                if parent.kmouseover&gt;=uiz_mouseclick then {
                                    simg = 4
                                } else {
                                    simg = 3
                                }
                            } else {
                                simg = 0
                            }
                        }


                        draw_sprite_ext(spriteconnectiontop, simg, nrx, ry + uy - parent.thickness, thickness / sprite_get_width(spriteconnectiontop), parent.thickness / sprite_get_height(spriteconnectiontop), 0, c_white, 1)
                    }
                } else {
                    var nry = ry + uy
                }

                var nrlx = rx + ux + uwidth
                //var nrly=ry+uy+uheight

                if inlistpos + 1 &lt; parent.divisions and parent.hasBar[inlistpos] then {
                    var nrly = ry + uy + uheight// - parent.thickness / 2
                    if spriteconnectionbottom != 0 then {
                        if global.mouseover = id and overframebar = i then {
                            if kmouseover&gt;=uiz_mouseclick then {
                                simg = 2
                            } else {
                                simg = 1
                            }
                        } else {
                            if global.mouseover = parent.id and parent.overframebar = inlistpos then {
                                if parent.kmouseover&gt;=uiz_mouseclick then {
                                    simg = 4
                                } else {
                                    simg = 3
                                }
                            } else {
                                simg = 0
                            }
                        }

                        draw_sprite_ext(spriteconnectionbottom, simg, nrx, nrly, thickness / sprite_get_width(spriteconnectionbottom), parent.thickness / sprite_get_height(spriteconnectionbottom), 0, c_white, 1)
                    }
                } else {
                    var nrly = ry + uy + uheight
                }


            } else {
                var nwidth = uwidth
                var nheight = uheight
                var nrx = rx + ux
                var nry = ry + uy
                var nrlx = rx + ux + uwidth
                var nrly = ry + uy + uheight
            }
            if sprite != 0 then {
                var nsw = sprite_get_width(sprite)
                var nsh = sprite_get_height(sprite)
                switch (texturemode_horizontal) {
                    case uiz_texturemode_fill:
                        var szx = 1
                        break;
                    case uiz_texturemode_tile:
                        var szx = nwidth / nsw
                        break;
                    case uiz_texturemode_tilefit:
                        var szx = round(nwidth / nsw);
                        break;
                    default:
                        szx = 1
                }
                switch (texturemode_vertical) {
                    case uiz_texturemode_fill:
                        var szy = 1
                        break;
                    case uiz_texturemode_tile:
                        var szy = nheight / nsh
                        break;
                    case uiz_texturemode_tilefit:
                        var szy = round(nheight / nsh);
                        break;
                    default:
                        szy = 1
                }
                //top
                
                if mouseover = id and overframebar = i then {
                    if kmouseover&gt;=uiz_mouseclick then {
                        tex = 2
                    } else {
                        tex = 1
                    }
                } else {
                    tex = 0
                }
                
                uiz_draw_sprite_tiles(sprite, tex, nrx, nry, nrlx, nrly, szx, szy, color, alpha, 0, 0);

            } else {
                draw_square(nrx, nry, nrlx, nrly, color, alpha)
            }
        }
    }
uiz_containend()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ds_exists(children,ds_type_list) then{ds_list_destroy(children)}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ds_exists(children,ds_type_list) then{ds_list_destroy(children)}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
