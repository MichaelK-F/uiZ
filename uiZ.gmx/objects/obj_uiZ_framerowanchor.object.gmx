<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///#define uiZ
//#exclude
uiz_objinit()
draw=false;
color=c_white
sprite=spr_uiZ_framepullline
texturemode_horizontal=uiz_texturemode_fill
texturemode_vertical=uiz_texturemode_fill
spriteconnectionleft=spr_uiZ_framepulllineconnectionleft
spriteconnectionright=spr_uiZ_framepulllineconnectionright
spriteconnectiontop=spr_uiZ_framepulllineconnectiontop
spriteconnectionbottom=spr_uiZ_framepulllineconnectionbottom
frameBarThickness = .10
frameBarThicknessType = dp
iscover=0
fromx=0
fromy=0
tox=0
toy=0
marginl=0
marginr=0
margint=0
marginb=0
margincellw=0
margincellh=0
margin=1
automargins=true;

snaptoparent=1
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>frameat[0]=noone
isize[0]=0
hasBar[0]=false;
minSize[0]=0;
minSizeType[0]=px;
maxSize[0]=0;
maxSizeType[0]=px;
absorbPixelDiff[0]=0;
absorbPixelDiffTotal = 0;
thickness=15
overframebar=0
lastmouse=0
snaptomouse=0
snaptobar=0
stopsnap=0
mousesnappoint=0;
toleft = 0;
lastFixSize = 0;
forceFixSize = true;

uiz_frameset_fixThickness();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ds_exists(children,ds_type_list) then{ds_list_destroy(children)}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>kmouseover = uiz_mouse_isOver_object_leftCheck(id); //needed here when mouse is frozen
uiz_frameset_rowanchor_CalculateOverFrameBar();

if kmouseover == uiz_mousereleased {
    if snaptomouse = 1 then {
        stopsnap = 0
        snaptomouse = 0
        uiz_mouse_unFreeze();
        uiz_updater_unstep();
    }
}
if snaptomouse &gt; 0 then {

    if uiz_getmouse_x() &lt; 0 or uiz_getmouse_y() &lt; 0 or uiz_getmouse_x() &gt; global.screenpxwidth or uiz_getmouse_y() &gt; global.screenpxheight then {
        stopsnap = true;
    }

    if stopsnap then {
        mousediff = 0;
    } else {
        mousediff = - ((uiz_getmouse_y() - frameat[overframebar].rly) - mousesnappoint);
    }
    lastmouse = uiz_getmouse_y();
    stopsnap = false;
    
    var bothHeight = frameat[snaptobar].height + frameat[snaptobar + 1].height
    if maxSize[snaptobar+1] == 0 then {
        var du = 0;
    } else {
        var du = bothHeight - uiz_getposy_self(maxSize[snaptobar+1], maxSizeType[snaptobar+1]);
    }
    
    if maxSize[snaptobar] == 0 then {
        var dm = 0;
    } else {
        var dm = bothHeight - uiz_getposy_self(maxSize[snaptobar], maxSizeType[snaptobar]);
    }
    
    var thisMinSize = max(uiz_getposy_self(minSize[snaptobar], minSizeType[snaptobar]), du, 0*(isizetype[snaptobar]==xtra));
    var otherMinSize = max(uiz_getposy_self(minSize[snaptobar + 1], minSizeType[snaptobar + 1]), dm, 0*(isizetype[snaptobar + 1]==xtra));
    var thisMaxSize = bothHeight - otherMinSize;
    var otherMaxSize = bothHeight - thisMinSize;
    
    if thisMinSize &gt; thisMaxSize then{
        sdbm("[uiZ|WARNING] Frameset minimum and frame maximum sizes are incompatible with each other!");
        exit;
    }
    
    //fix isz
    isz[snaptobar] -= mousediff
    if isz[snaptobar] &lt; thisMinSize then{
        isz[snaptobar] = thisMinSize;
    }else if isz[snaptobar] &gt; thisMaxSize then{
        isz[snaptobar] = thisMaxSize;
    }
    isz[snaptobar + 1] += mousediff
    if isz[snaptobar + 1] &lt; otherMinSize then{
        isz[snaptobar + 1] = otherMinSize;
    }else if isz[snaptobar + 1] &gt; otherMaxSize then{
        isz[snaptobar + 1] = otherMaxSize;
    }

    var oldISizeThis = isize[snaptobar];
    
    switch (isizetype[snaptobar]) {
        case px:
            isize[snaptobar] -= mousediff
            if isize[snaptobar] &lt; thisMinSize then{
                isize[snaptobar] = thisMinSize;
                stopsnap = true;
            }else if isize[snaptobar] &gt; thisMaxSize then{
                isize[snaptobar] = thisMaxSize;
                stopsnap = true;
            }
            break;
        case fc:
            isize[snaptobar] = min(1 - 1 / height, max(1 / height, ((isize[snaptobar] * height) - mousediff) / height))
            if isize[snaptobar] &lt; thisMinSize / height then{
                isize[snaptobar] = thisMinSize / height;
                stopsnap = true;
            }else if isize[snaptobar] &gt; thisMaxSize / height then{
                isize[snaptobar] = thisMaxSize / height;
                stopsnap = true;
            }
            break;
        case dp:
            isize[snaptobar] -= mousediff / uiz_dp
            if isize[snaptobar] &lt; thisMinSize / uiz_dp then{
                isize[snaptobar] = thisMinSize / uiz_dp;
                stopsnap = true;
            }else if isize[snaptobar] &gt; thisMaxSize / uiz_dp then{
                isize[snaptobar] = thisMaxSize / uiz_dp;
                stopsnap = true;
            }
            break;
    }
    
    var oldISizeOther = isize[snaptobar + 1];
    
    switch (isizetype[snaptobar + 1]) {
        case px:
            isize[snaptobar + 1] += mousediff
            if isize[snaptobar + 1] &lt; otherMinSize then{
                isize[snaptobar + 1] = otherMinSize;
                stopsnap = true;
            }else if isize[snaptobar + 1] &gt; otherMaxSize then{
                isize[snaptobar + 1] = otherMaxSize;
                stopsnap = true;
            }
            break;
        case fc:
            isize[snaptobar + 1] = min(1 - 1 / height, max(1 / height, ((isize[snaptobar + 1] * height) + mousediff) / height))
            if isize[snaptobar + 1] &lt; otherMinSize / height then{
                isize[snaptobar + 1] = otherMinSize / height;
                stopsnap = true;
            }else if isize[snaptobar + 1] &gt; otherMaxSize / height then{
                isize[snaptobar + 1] = otherMaxSize / height;
                stopsnap = true;
            }            
            break;
        case dp:
            isize[snaptobar + 1] += mousediff / uiz_dp
            if isize[snaptobar + 1] &lt; otherMinSize / uiz_dp then{
                isize[snaptobar + 1] = otherMinSize / uiz_dp;
                stopsnap = true;
            }else if isize[snaptobar + 1] &gt; otherMaxSize / uiz_dp then{
                isize[snaptobar + 1] = otherMaxSize / uiz_dp;
                stopsnap = true;
            }
            break;
    }
    
    if isizetype[snaptobar]==xtra then{
        if isizetype[snaptobar+1]==xtra then{
        //BOTH XTRA
            var startSize = floor(toleft / starsr);
        
            var newH = (frameat[snaptobar].height - mousediff);
            if newH &lt; thisMinSize then{
                newH = thisMinSize;
                stopsnap = true;
            }else if newH &gt; thisMaxSize then{
                newH = thisMaxSize;
                stopsnap = true;
            }
            
            var oldIsize = isize[snaptobar];
            var totISize = isize[snaptobar] + isize[snaptobar + 1];
            isize[snaptobar] = newH / startSize;
            isize[snaptobar + 1] -= (isize[snaptobar] - oldIsize)
            var newTotISize = isize[snaptobar] + isize[snaptobar + 1];
            
            //recalculate starsr to forgo rounding errors
            starsr = 0;
            for (var i = 0; i &lt; divisions; i++) {
                if isizetype[i]==xtra then{
                    starsr+=isize[i];
                }
            }
            
            uiz_frameset_fixAbsorbPixelDiff(0);
        }else{
        //TOP FRAME ONLY XTRA
            switch (isizetype[snaptobar + 1]) {
                case px:
                    var toleftOffset = (isize[snaptobar + 1] - oldISizeOther)
                    break;
                case fc:
                    var toleftOffset = (isize[snaptobar + 1] - oldISizeOther)*height
                    break;
                case dp:
                    var toleftOffset = (isize[snaptobar + 1] - oldISizeOther)*uiz_dp
                    break;
            }
            //get total amount of xtra
            uiz_frameset_handleExtraOffset(toleftOffset, 0);
        }
    } else if isizetype[snaptobar+1]==xtra then{
        //BOTTOM FRAME ONLY XTRA
        switch (isizetype[snaptobar]) {
            case px:
                var toleftOffset = (isize[snaptobar] - oldISizeThis)
                break;
            case fc:
                var toleftOffset = (isize[snaptobar] - oldISizeThis)*height
                break;
            case dp:
                var toleftOffset = (isize[snaptobar] - oldISizeThis)*uiz_dp
                break;
        }
        //get total amount of xtra
        uiz_frameset_handleExtraOffset(toleftOffset, 1);
    }
    
    uiz_framesetfixhorizontal(id);
    uiz_updater_FixViews();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_frameset_rowanchor_CalculateOverFrameBar();

//update view
var y1 = frameat[overframebar].rly;
var y2 = y1 + thickness;
var extendLeft = 0;
var extendRight = 0;
if parent.object_index = obj_uiZ_framecolanchor then {
    if inlistpos &gt; 0 and parent.hasBar[inlistpos - 1] then {
        extendLeft = parent.thickness;
    }
    if inlistpos + 1 &lt; parent.divisions and parent.hasBar[inlistpos] then {
        extendRight = parent.thickness;
    }
}
uiz_updater_FixViews_area_selfmarked(rx-extendLeft,y1,rlx+extendRight,y2);

switch(kmouseover){
    case uiz_mousepressed:
        if snaptomouse = 0 and hasBar[overframebar] then {
            snaptomouse = 1
            snaptobar = overframebar
            mousesnappoint = uiz_getmouse_y() - frameat[overframebar].rly;
            global.mousefrozen = 1
            lastmouse = uiz_getmouse_y()
            uiz_mouse_freeze();
            uiz_updater_step();
        }
    break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_mouse_docheck()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if draw and uiz_cntn() then{
    var ux, uwidth, uy, uheight
    var h = 0//-thickness / 2;
    draw_set_alpha(alpha)
    draw_set_color(color)
    for (var i = 0; i &lt; divisions - 1; i++) {
        h += isz[i]
        if hasBar[i] = 1 then {
            ux = 0
            uwidth = width
            //get the y of the frames
            
            uy = h
            uheight = thickness
            if parent.object_index = obj_uiZ_framecolanchor then {
                var nwidth = uwidth
                var nheight = uheight
                var nry = ry + uy
                //var nry=ry+uy
                if inlistpos &gt; 0 and parent.hasBar[inlistpos - 1] then {
                    var nrx = rx + ux //+parent.thickness/2
                    if spriteconnectiontop != 0 then {
                        var simg;
                        if global.mouseover = id and overframebar = i then {
                            if kmouseover&gt;=uiz_mouseclick then {
                                simg = 2
                            } else {
                                simg = 1
                            }
                        } else {
                            if global.mouseover = parent.id and parent.overframebar = inlistpos - 1 then {
                                if parent.kmouseover&gt;=uiz_mouseclick then {
                                    simg = 4
                                } else {
                                    simg = 3
                                }
                            } else {
                                simg = 0
                            }
                        }


                        draw_sprite_ext(spriteconnectionleft,simg,rx+ux-parent.thickness,nry,parent.thickness/sprite_get_width(spriteconnectionleft),thickness/sprite_get_height(spriteconnectionleft),0,c_white,1)
                    }
                } else {
                    var nrx = rx + ux
                }

                //var nrlx = rx + ux + uwidth
                var nrly = ry + uy + uheight

                if inlistpos + 1 &lt; parent.divisions and parent.hasBar[inlistpos]  then {
                    var nrlx = rx + ux + uwidth// - parent.thickness / 2
                    if spriteconnectionbottom != 0 then {
                        if global.mouseover = id and overframebar = i then {
                            if kmouseover&gt;=uiz_mouseclick then {
                                simg = 2
                            } else {
                                simg = 1
                            }
                        } else {
                            if global.mouseover = parent.id and parent.overframebar = inlistpos then {
                                if parent.kmouseover&gt;=uiz_mouseclick then {
                                    simg = 4
                                } else {
                                    simg = 3
                                }
                            } else {
                                simg = 0
                            }
                        }

                        draw_sprite_ext(spriteconnectionright,simg,nrlx,nry,parent.thickness/sprite_get_width(spriteconnectionright),thickness/sprite_get_height(spriteconnectionright),0,c_white,1)
                    }
                } else {
                    var nrlx = rx + ux + uwidth
                }


            } else {
                var nwidth = uwidth
                var nheight = uheight
                var nrx = rx + ux
                var nry = ry + uy
                var nrlx = rx + ux + uwidth
                var nrly = ry + uy + uheight
            }
            if sprite != 0 then {
                var nsw = sprite_get_width(sprite)
                var nsh = sprite_get_height(sprite)
                switch (texturemode_horizontal) {
                    case uiz_texturemode_fill:
                        var szx = 1
                        break;
                    case uiz_texturemode_tile:
                        var szx = nwidth / nsw
                        break;
                    case uiz_texturemode_tilefit:
                        var szx = round(nwidth / nsw);
                        break;
                    default:
                        szx = 1
                }
                switch (texturemode_vertical) {
                    case uiz_texturemode_fill:
                        var szy = 1
                        break;
                    case uiz_texturemode_tile:
                        var szy = nheight / nsh
                        break;
                    case uiz_texturemode_tilefit:
                        var szy = round(nheight / nsh);
                        break;
                    default:
                        szy = 1
                }
                //texture_set_repeat(0)
                //top
                
                if mouseover = id and overframebar = i then {
                    if kmouseover&gt;=uiz_mouseclick then {
                        tex = 2
                    } else {
                        tex = 1
                    }
                } else {
                    tex = 0
                }
                
                uiz_draw_sprite_tiles(sprite, tex, nrx, nry, nrlx, nrly, szx, szy, color, alpha, 0, 0);
                
            } else {
                draw_square(nrx, nry, nrlx, nrly, color, alpha)
            }
        }
    }
    uiz_containend()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ds_exists(children,ds_type_list) then{ds_list_destroy(children)}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ds_exists(children,ds_type_list) then{ds_list_destroy(children)}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
