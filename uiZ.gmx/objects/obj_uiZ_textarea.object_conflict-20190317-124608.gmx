<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///#define uiZ
//#sprite images
//#spritenum 24
//#objectversion 1.0
uiz_objinit()
font=-1//f//font//
textcolor=c_black//c//text color//
selecttextcolor=c_white//c//selection text color//
selectbackcolor=12820740//c//selection background color//

scrollbarsize=0.2//v//scrollbarsize//
scrollbarsizetype=dp//z//scrollbarsizetype//
scrollbarsprite=spr_uiZ_scrollbar//p//sprite//
scrollbarcolor=c_white//c//color//
scrollbartexturemode=uiz_texturemode_fill_edgeless//t//texturemode//
scrollspeed=50//v//scrollspeed//


accountspeed=1//v//rapid mode count time//
accbetween=0.000001//v//rapid mode speed//

typeanimationin=uiz_exponential_in//a//type animation in//
typeanimationout=uiz_exponential_in//a//type animation out//
typeAnimationTime=1//v//type animation time//
typecolor=c_black//c//type indicater color//
cursorwidth=3//c//type indicater thickness//

clippedLineEnableFactor=0.5;//v//clipped line factor//

hasbackground=true;
texturescript=uiz_back_circlestitch//i//texturescript//
texturescript_over=-1//i//texturescript over//
texturescript_in=-1//i//texturescript in//
texturescript_out=-1//i//texturescript out//

sprite_normal=spr_uiZ_border1//p//sprite normal//
color_normal=c_white//c//color normal//
margin_normal=5//v//margin normal//
sprite_texturemode=uiz_texturemode_fill//t//texturemode normal
border_texturemode=-1//t//texturemode border//

sprite_over=spr_uiZ_border1_over//p//sprite over//
color_over=-1//c//color over//
margin_over=-1//v//margin over//

sprite_in=spr_uiZ_border1_in//p//sprite in//
color_in=-1//c//color in//
margin_in=-1//v//margin in//

sprite_out=spr_uiZ_border1_in//p//sprite out//
color_out=-1//c//color out//
margin_out=-1//v//margin out//
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>textList = ds_list_create();
fontHeight=string_height("{|}");

doscroll=false;
scroll=-1;
scrolllines=0;
scblwidth=0;
listFromPx=0;


//isTyping and hasSelection should never be true at the same time. If that's the case it should be considered a bug.
isTyping=false;
hasSelection=false;

hasMousePressed=false;
redoSelection=false;

selection1Line=-1;
selection1X=-1;
selection1Char=-1;

selection2Line=-1;
selection2X=-1;
selection2Char=-1;

selectionMinLine=selection1Line;
selectionMinX=selection1X;
selectionMinChar=selection1Char;

selectionMaxLine=selection2Line;
selectionMaxX=selection2X;
selectionMaxChar=selection2Char;

last_selectionMinLine=selectionMinLine;
last_selectionMinChar=selectionMinChar;

last_selectionMaxLine=selectionMaxLine;
last_selectionMaxChar=selectionMaxChar;

lastReworkAvWidth = -1;

last_isScrollbarSelected = false;

addToNextLineCheck_sel1 = true;
addToNextLineCheck_sel2 = true;

typeanimcount=0;
account=0;

whatsign="";
changesign = false;
lastkeyboard_key = keyboard_key;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_textarea_end();
uiz_endobject()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//check if step event is still valid
if (global.mouseover!=id &amp;&amp; mouse_check_button(mb_left)
//&amp;&amp; !(instance_exists(global.mouseover) &amp;&amp; (global.mouseover.object_index=obj_uiZ_window &amp;&amp; (global.mouseover.isresizing || global.mouseover.isresizing)))
) || (isTyping==false &amp;&amp; hasSelection==false){
    uiz_updater_unstep();
    uiz_typecursor_deregister();
    isTyping=false;
    exit;
}

//handle typing animation
typeanimcount=uiz_animation_increasecounter(typeanimcount, typeAnimationTime)
uiz_typecursor_setalpha(uiz_animation_getfunction_twoway(typeanimcount,uiz_exponential_in,uiz_exponential_in))

//handle typing
if keyboard_check(vk_control) then {

}else{//control isn't pressed

//control isn't pressed
        if keyboard_check(keyboard_key) and!(keyboard_key = 0) then {
            account = min(account + (1 / (accountspeed * room_speed)), 1)
        } else {
            account = 0
        }
        if lastkeyboard_key != keyboard_key then {
            account = 0
        }
        if (keyboard_check_pressed(keyboard_key) or account = 1) and!(keyboard_key = 0) then {
        //do typing
        account = max(account - ((accbetween * room_speed)), 0)

        if hasSelection then {
            
        }else{//!hasSelection
            switch (keyboard_key) {
            case vk_backspace:
                uiz_textarea_doBackspace(0);
            break;
            case vk_delete:
                uiz_textarea_doBackspace(1);
            break;
            default:
                
                if keyboard_check(vk_control) or keyboard_check(vk_alt) or(keyboard_key &gt;= 112 and keyboard_key &lt;= 123) or keyboard_key = 174 or keyboard_key = 175 then {} else {
                    if changesign then {
                        uiz_textarea_addchar(uiz_returncharaddon(string_char_at(keyboard_string, string_length(keyboard_string)), whatsign))
                    } else {
                        uiz_textarea_addchar(string_char_at(keyboard_string, string_length(keyboard_string)))
                    }
                    whatsign = ""
                    changesign = false;
                    //}
            
            break;
                    break;
                }
            }
        }
                
        }
}
lastkeyboard_key = keyboard_key
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if doscroll=true then{
    scroll = uiz_drawscrollbar_vertical_step(ilx-scblwidth,iy,ilx,ily,scroll,scrolllines,true,scrollspeed);
    var oldListFrom = listFromPx;
    listFromPx=uiz_drawscrollbar_getscrollvalue(scroll);
    if oldListFrom!=listFromPx then{
        uiz_updater_FixViews_inside();
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///handle selections
//get current mouse position
if doscroll=true then{
var scrbx = ilx-scblwidth;
}else{
var scrbx = ilx;
}
var isScrollbarSelected = uiz_drawscrollbar_getselected(scroll);
if kmouseover&gt;=uiz_mouseclick &amp;&amp; (doscroll=false or (uiz_getmouse_x()&lt;scrbx &amp;&amp; !isScrollbarSelected &amp;&amp; !last_isScrollbarSelected)) then{

    uiz_mouse_freeze();
    var selectionCLine=-1;
    var selectionCX=-1;
    var selectionCChar=-1;
    
    
    var lsz = ds_list_size(textList);
    if lsz=0 then{
                exit;
    }
    selectionCLine=floor((uiz_getmouse_y()-iy+listFromPx)/fontHeight);
    if selectionCLine &gt;=lsz then{
        selectionCLine=lsz-1;
        selectionCChar = string_length(textList[| selectionCLine]);
        selectionCX = ilx;//string_width(textList[| selectionCLine])
    }else{
        if selectionCLine&lt;0 then{
            selectionCLine=0;
            selectionCChar=0;
            selectionCX=ix;
            //selectionCChar = string_length(textList[| 0]);
            //selectionCX = string_width(textList[| 0])
        }else{
            var testLine = textList[| selectionCLine];
            var testLineSz = string_length(testLine);
            var curX=ix;
            selectionCX=curX;
            var mouseX = uiz_getmouse_x();
            
            for(var i=1;i&lt;=testLineSz;i++){
                var w = string_width(string_char_at(testLine,i));
                if curX+w/2&gt;mouseX then{//when this mouse is further selected beyond this character
                    selectionCChar=i-1;
                    selectionCX=curX;
                    break;
                }
                curX+=w;
            }
            
            if (i&gt;testLineSz){//loop was looped fully, so no selection position was found, just assume the last character then.
                selectionCChar=testLineSz;
                selectionCX=curX;
            }
            }
    }
    //handle the newly gotten selection point
    var hadSelection = hasSelection;
    if mouse_check_button_pressed(mb_left)  then{
        hasMousePressed=true;
        selection1Line=selectionCLine;
        selection1X=selectionCX;
        selection1Char=selectionCChar;
    }
        selection2Line=selectionCLine;
        selection2X=selectionCX;
        selection2Char=selectionCChar;
        
        if uiz_textarea_selectionAreTheSame(){//check type/selection state
            hasSelection=false;
            if !mouse_check_button(mb_left) then{
                isTyping=true;
                uiz_updater_step();
                uiz_textarea_registerTypeCursor();
            }
        }else{
            isTyping=false;
            hasSelection=true;
        }
        if !mouse_check_button(mb_left) then{
            uiz_mouse_unfreeze();
            //hasMousePressed=false;
        }
        
        if hasSelection or hadSelection then{
            uiz_textarea_saveMinMaxSnapshot()
        }
        uiz_textarea_genMinMax();
        if (hasSelection or hadSelection) and uiz_textarea_hasMinMaxChangedSinceSnapshot() then{//update view
            uiz_updater_FixViews_area_selfmarked(ix,iy+fontHeight*min(last_selectionMinLine,selectionMinLine)-listFromPx,scrbx-1,iy+fontHeight*(max(last_selectionMaxLine,selectionMaxLine)+1)-listFromPx);
        }
        
    
}
last_isScrollbarSelected=isScrollbarSelected;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_mouse_docheck()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if uiz_cntn() then{
//draw background
uiz_back()

//setup text settings
draw_set_valign(fa_top)
draw_set_halign(fa_left)

//set style
if font&gt;-1 then{draw_set_font(font);}
draw_set_color(textcolor);


//get what lines should be drawn
var listLen = ds_list_size(textList);

var listFrom = max((cntny-iy-listFromPx)/fontHeight,listFromPx/fontHeight);
if cntnly&gt;=iy and cntnly&lt;=ily then{
var listTo = min(listLen,listFrom+iheight/fontHeight,(cntnly-iy-listFromPx)/fontHeight);
}else{
var listTo = min(listLen,listFrom+iheight/fontHeight);
}



if redoSelection=true and hasSelection=true then{
    var listFrom = max(min(last_selectionMinLine,selectionMinLine),listFrom);
    var listTo = min(max(last_selectionMaxLine,selectionMaxLine),listTo);
}

var listFromFloor = floor(listFrom);
var listFromCeil = ceil(listFrom);
var listToFloor = floor(listTo);
var listToCeil = ceil(listTo);

redoSelection=false;

if doscroll=true then{
var scrbx = ilx-scblwidth;
}else{
var scrbx = ilx;
}

//draw selection background on full lines
var begSelMainBodyY=iy+fontHeight*(selectionMinLine+1)-listFromPx
if(selectionMaxLine-selectionMinLine&gt;1 &amp;&amp; begSelMainBodyY&lt;ily &amp;&amp; hasSelection){
    //draw_square(selectionMinX,iy,selectionMaxX,lineY+fontHeight,selectbackcolor,1);
    draw_square(ix,begSelMainBodyY,scrbx-1,min(ily,iy+fontHeight*(selectionMaxLine)-listFromPx),selectbackcolor,1);
    //draw_square(ix,iy+(fontHeight+1)*(selectionMaxLine)-listFromPx,selectionMaxX,ily,selectbackcolor,1);
}

//sdbm("listcolorsel: ",listFromCeil,selectionMinLine,listToFloor,selectionMaxLine)
//set color for lines
//if selectionMinLine&gt;=0 &amp;&amp; selectionMinLine&lt;listFromFloor  then{
if selectionMinLine&gt;=0 &amp;&amp; selectionMinLine&lt;=listFrom-clippedLineEnableFactor &amp;&amp; selectionMaxLine&gt;=listFrom-clippedLineEnableFactor then{// &amp;&amp; selectionMaxLine&gt;listFromFloor then{
    draw_set_color(selecttextcolor);
}else{
    draw_set_color(textcolor);
}
//acutally draw the lines

//draw first (clipped) line
if listFromFloor!=listFrom &amp;&amp; (listFrom-listFromFloor&lt;clippedLineEnableFactor) then{
 if hasSelection then{
    var lineY = iy+fontHeight*listFromFloor-listFromPx;
    if listFromFloor=selectionMinLine &amp;&amp; listFromFloor=selectionMaxLine then{
        draw_text(ix,iy,string_copy(textList[| listFromFloor],1,selectionMinChar));
        draw_text(selectionMaxX,iy,string_copy(textList[| listFromFloor],selectionMaxChar+1,string_length(textList[|listFromFloor]))); 
        draw_square(selectionMinX,iy,selectionMaxX,lineY+fontHeight,selectbackcolor,1);
        draw_set_color(selecttextcolor);
        draw_text(selectionMinX,iy,string_copy(textList[| listFromFloor],selectionMinChar+1,selectionMaxChar-selectionMinChar)); 
        draw_set_color(textcolor);
    }else if listFromFloor=selectionMinLine then{
        draw_text(ix,iy,string_copy(textList[| listFromFloor],1,selectionMinChar));
        draw_square(selectionMinX,iy,scrbx-1,lineY+fontHeight,selectbackcolor,1);
        draw_set_color(selecttextcolor);
        draw_text(selectionMinX,iy,string_copy(textList[| listFromFloor],selectionMinChar+1,string_length(textList[| listFromFloor])-selectionMinChar)); 
    }else if listFromFloor=selectionMaxLine then{
        draw_square(ix,iy,selectionMaxX,lerp(iy,lineY,1-(listFrom-listFromFloor)*2)+fontHeight,selectbackcolor,1);
        draw_set_color(selecttextcolor);
        draw_text(ix,iy,string_copy(textList[| listFromFloor],1,selectionMaxChar)); 
        draw_set_color(textcolor);
        //draw surrounding selection
        draw_text(selectionMaxX,iy,string_copy(textList[| listFromFloor],selectionMaxChar+1,string_length(textList[|listFromFloor]))); 
    }
    }else{
        draw_text(ix,iy,textList[| listFromFloor]);
    }
     
}


if selectionMinLine&gt;=0 &amp;&amp; selectionMaxLine&gt;=0 &amp;&amp; listFromCeil&lt;=selectionMaxLine &amp;&amp; listToFloor&gt;=selectionMinLine then{
//text begins with selected text
//draw_set_color(selecttextcolor);
}


//draw main lines
for(var i=listFromCeil;i&lt;listToFloor;i++){
    var lineY = iy+fontHeight*i-listFromPx;
    if i&gt;=selectionMinLine &amp;&amp; i&lt;=selectionMaxLine &amp;&amp; hasSelection then{
        if i=selectionMinLine &amp;&amp; i=selectionMaxLine then{
            //draw surrounding selection
            draw_text(ix,lineY,string_copy(textList[| i],1,selectionMinChar));
            draw_text(selectionMaxX,lineY,string_copy(textList[| i],selectionMaxChar+1,string_length(textList[|i]))); 
            //draw selecion itself
            draw_square(selectionMinX,lineY,selectionMaxX,lineY+fontHeight,selectbackcolor,1);
            draw_set_color(selecttextcolor);
            draw_text(selectionMinX,lineY,string_copy(textList[| i],selectionMinChar+1,selectionMaxChar-selectionMinChar)); 
            draw_set_color(textcolor);
            continue;
        }
        if i=selectionMinLine then{
            //draw surrounding selection
            draw_text(ix,lineY,string_copy(textList[| i],1,selectionMinChar));
            //draw selection itself
            draw_square(selectionMinX,lineY,scrbx-1,lineY+fontHeight,selectbackcolor,1);
            draw_set_color(selecttextcolor);
            draw_text(selectionMinX,lineY,string_copy(textList[| i],selectionMinChar+1,string_length(textList[| i])-selectionMinChar)); 
            continue;
        }
        
        if i=selectionMaxLine then{
            //draw selection itself
            draw_square(ix,lineY,selectionMaxX,lineY+fontHeight,selectbackcolor,1);
            draw_set_color(selecttextcolor);
            draw_text(ix,lineY,string_copy(textList[| i],1,selectionMaxChar)); 
            draw_set_color(textcolor);
            //draw surrounding selection
            draw_text(selectionMaxX,lineY,string_copy(textList[| i],selectionMaxChar+1,string_length(textList[|i]))); 
            continue;
        }
           //we came here so we have fully selected line, just draw the text outside this if. 
        }
        
    
    draw_text(ix,lineY,textList[| i]); 

       
    
}

//draw last (clipped) line
if listTo!=listToFloor &amp;&amp; (listTo-listToFloor&gt;clippedLineEnableFactor) then{
    draw_set_valign(fa_bottom);
    if (listToFloor==selectionMaxLine || listToFloor==selectionMinLine) then{
        var lineY = iy+fontHeight*listToFloor-listFromPx;
        if listToFloor=selectionMaxLine then{
        draw_square(ix,min(ily,max(ily-fontHeight,iy+fontHeight*(selectionMaxLine)-listFromPx)),selectionMaxX,ily,selectbackcolor,1);
        draw_set_color(selecttextcolor);
        draw_text(ix,ily,string_copy(textList[| listToFloor],1,selectionMaxChar)); 
        draw_set_color(textcolor);
        //draw surrounding selection
        draw_text(selectionMaxX,ily,string_copy(textList[| listToFloor],selectionMaxChar+1,string_length(textList[|listToFloor])));
        }else{//listToFloor=selectionMinLine
        //draw normal selection
        draw_text(ix,ily,string_copy(textList[| listToFloor],1,selectionMinChar));  
        //draw selection
        
        draw_square(selectionMinX,min(ily,lerp(ily-fontHeight,iy+fontHeight*(selectionMinLine)-listFromPx,1-(listFrom-listFromFloor)*2)),scrbx-1,ily,selectbackcolor,1);
        draw_set_color(selecttextcolor);
        draw_text(selectionMinX,ily,string_copy(textList[| listToFloor],selectionMinChar+1,string_length(textList[|listToFloor])));
        }
        
    }else{
        draw_text(ix,ily,textList[| listToFloor]);
    }
    
}

//draw scrollbar
if doscroll=true then{
uiz_drawscrollbar_vertical_draw(scrbx,iy,ilx,ily,scrollbarsprite,scrollbarcolor,scrollbartexturemode,scroll,scrolllines)
}

uiz_containend()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_textarea_end();
uiz_endobject()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_textarea_end();
uiz_endobject()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw_square(100,100,500,1000,c_gray,0.7);
draw_set_alpha(1);
//draw_set_color(c_green)
//draw_rectangle(ix+posx,iy,ix+posx+extraLineWidth+10,iy+10,false)
draw_set_color(c_black)


var h=100;

draw_text(100,h,"hasSelection: "+string(hasSelection));
h+=string_height("1")+10;
draw_text(100,h,"isTyping: "+string(isTyping));
h+=string_height("1")+10;

draw_text(100,h,"list size: "+string(ds_list_size(textList)));
h+=string_height("1")+10;
draw_text(100,h,"scroll: "+string(scroll));
h+=string_height("1")+10;

draw_text(100,h,"selection1Line: "+string(selection1Line));
h+=string_height("1")+10;
draw_text(100,h,"selection1X: "+string(selection1X));
h+=string_height("1")+10;
draw_text(100,h,"selection1Char: "+string(selection1Char));
h+=string_height("1")+10;

draw_text(100,h,"selectionMinLine: "+string(selectionMinLine));
h+=string_height("1")+10;
draw_text(100,h,"selectionMinX: "+string(selectionMinX));
h+=string_height("1")+10;
draw_text(100,h,"selectionMinChar: "+string(selectionMinChar));
h+=string_height("1")+10;

draw_text(100,h,"selectionMaxLine: "+string(selectionMaxLine));
h+=string_height("1")+10;
draw_text(100,h,"selectionMaxX: "+string(selectionMaxX));
h+=string_height("1")+10;
draw_text(100,h,"selectionMaxChar: "+string(selectionMaxChar));
h+=string_height("1")+10;

draw_text(100,h,"lines: "+string(ds_list_size(textList)));
h+=string_height("1")+10;
draw_text(100,h,"selectionMaxX: "+string(string_width(textList[|ds_list_size(textList)-1])));
h+=string_height("1")+10;
draw_text(100,h,"selectionchars: "+string(string_length(textList[|ds_list_size(textList)-1])));
h+=string_height("1")+10;

draw_text(100,h,"hasSelection: "+string(hasSelection));
h+=string_height("1")+10;

draw_text(100,h,"sign(selection2Line-selection1Line): "+string(sign(selection2Line-selection1Line)));
h+=string_height("1")+10;

//get what lines should be drawn
var listLen = ds_list_size(textList);

if redoSelection=true and hasSelection=true then{
    var listFrom = max(min(last_selectionMinLine,selectionMinLine),listFromPx/fontHeight);
    var listTo = min(max(last_selectionMaxLine,selectionMaxLine),listFrom+iheight/fontHeight);
}else{
    var listFrom = (listFromPx/fontHeight);
    var listTo = min(listLen,listFrom+iheight/fontHeight);
}

var listFromFloor = floor(listFrom);
var listFromCeil = ceil(listFrom);
var listToFloor = floor(listTo);
var listToCeil = ceil(listTo);
draw_text(100,h,"listFrom: "+string(listFrom));
h+=string_height("1")+10;
draw_text(100,h,"listTo: "+string(listTo));
h+=string_height("1")+10;


draw_text(100,h,"mousefrozen: "+string(global.mousefrozen));
h+=string_height("1")+10;
draw_text(100,h,"mouse_button: "+string(mouse_check_button(mb_left)));
h+=string_height("1")+10;
draw_text(100,h,"mouse_pressed: "+string(mouse_check_button_pressed(mb_left)));
h+=string_height("1")+10;
draw_text(100,h,"kmouseover: "+string(kmouseover));
h+=string_height("1")+10;

draw_text(100,h,"global.uiz_stepNumber: "+string(global.uiz_stepNumber));
h+=string_height("1")+10;

/*
draw_set_color(c_red);
draw_line_width(selection1X,iy+selection1Line*fontHeight,selection1X,iy+(selection1Line+1)*fontHeight,1);
draw_set_color(c_green);
draw_line_width(selection2X,iy+selection2Line*fontHeight,selection2X,iy+(selection2Line+1)*fontHeight,1);
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
