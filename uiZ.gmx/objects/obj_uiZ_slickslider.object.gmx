<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_objinit()

linethickness=3//v//line thickness//
linethicknesstype=px//z//line thickness type//
sliderthickness=0.2//v//slider thickness//
sliderthicknesstype=dp//z//slider thickness type//
slidermargin=4//v//slider height margin//
slidermargintype=px//z//slider height margin type//
linecolor=c_blue//c//line color//
linemargin=3//v//line margin//

animation=uiz_acceldecel//a//click animation//
animationtime=0.5//v//click animation time in seconds//
animationcount=0;
anim=0;

oldvalue=0;
newvalue=0;
value=0//v//starting value (0-1)//
update=0
updated=0
hasmouse=0;
w=1;
snapx=0;
pm1x=0;
pm2x=0;

hasbackground=true;
texturescript=uiz_back_circlestitch//i//texturescript//
texturescript_over=-1//i//texturescript over//
texturescript_in=-1//i//texturescript in//
texturescript_out=-1//i//texturescript out//

sprite_normal=spr_uiZ_border1//p//sprite normal//
color_normal=c_white//c//color normal//
margin_normal=5//v//margin normal//
sprite_texturemode=uiz_texturemode_fill//t//texturemode normal
border_texturemode=-1//t//texturemode border//

sprite_over=spr_uiZ_border1_over//p//sprite over//
color_over=-1//c//color over//
margin_over=-1//v//margin over//

sprite_in=spr_uiZ_border1_in//p//sprite in//
color_in=-1//c//color in//
margin_in=-1//v//margin in//

sprite_out=spr_uiZ_border1_in//p//sprite out//
color_out=-1//c//color out//
margin_out=-1//v//margin out//
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if hasmouse=true then{
//value=clamp(value-(global.lastmousemovedx/(width-w)),0,1);
value=clamp(((uiz_getmouse_x()-rx-snapx)/(width-w)),0,1)
}else{
//handle animation
if anim=1 then{
animationcount+=uiz_sc(animationtime);
value=oldvalue+uiz_animation_getFunction(animationcount,animation)*(newvalue-oldvalue)
update=1;
if animationcount&gt;=1 then{
animationcount=0;
anim=0;
updated=1;
update=0;

uiz_updater_unstep();

}

}else{
uiz_updater_unstep();
}
}
uiz_updater_FixViews_area_selfmarked(p1x-bkmar,p1y-bkmar,p2x+bkmar,p2y+bkmar);
pm1x=p1x-bkmar-3;
pm2x=p2x+bkmar+2;
uiz_slickslider_calcKnobPoints();
uiz_updater_FixViews_area_selfmarked(p1x-bkmar,p1y-bkmar,p2x+bkmar,p2y+bkmar);
pm1x=min(pm1x,p1x-bkmar-3);
pm2x=max(pm2x,p2x+bkmar+2);
pm1x=clamp(pm1x,rx+linemargin,rlx-linemargin);
pm2x=clamp(pm2x,rx+linemargin,rlx-linemargin);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>update=0
updated=0
var hasmouse_old=hasmouse;
if mouse_check_button(mb_left)=false then{
hasmouse=0.5;
global.mousefrozen=false;
}

if point_in_rectangle(uiz_getmouse_x(),uiz_getmouse_y(),p1x,p1y,p2x,p2y) then{
if hasmouse=false then{hasmouse=0.5}
if kmouseover=3 then{
snapx=uiz_getmouse_x()-p1x;
uiz_updater_step();
hasmouse=true;
global.mousefrozen=true;
}
}else{
if hasmouse&lt;true then{hasmouse=false;}
}
if hasmouse!=hasmouse_old then{

uiz_fix_Background(hasmouse*2);
//uiz_updater_FixViews_area_selfmarked(p1x-bkmar,p1y-bkmar,p2x+bkmar,p2y+bkmar);
//pm1x=max(p1x-bkmar,rx+linemargin);
//pm2x=min(p2x+bkmar,rlx-linemargin);
uiz_updater_FixViews();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if hasmouse=true and kmouseover&gt;0 then{uiz_set_cursor(cr_handpoint)}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if kmouseover&lt;=1 and hasmouse=true then{
hasmouse=false;
updated=1
}
if kmouseover=0 and global.mousefrozen=0 then{
hasmouse=0;
}

if hasmouse=false and kmouseover=4 then{
uiz_updater_step();
//set animation
if anim=0 then{anim=1; animationcount=0;
oldvalue=value;
newvalue=(uiz_getmouse_x()-rx-w/2)/(width-w)
}else{
oldvalue=value;
newvalue=(uiz_getmouse_x()-rx-w/2)/(width-w)
animationcount=0;
}
}

if kmouseover&gt;0 then{uiz_set_cursor(cr_handpoint)}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_mouse_docheck()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if uiz_cntn() then{
draw_set_alpha(alpha)
draw_set_color(linecolor)
if uiz_selfmarked=true then{
//draw_line_width(rx+linemargin,ry+height/2,rlx-linemargin,ry+height/2,linethickness)
draw_line_width(pm1x,ry+height/2,pm2x,ry+height/2,linethickness)
}else{

draw_line_width(rx+linemargin,ry+height/2,rlx-linemargin,ry+height/2,linethickness)
}


uiz_back_at(p1x,p1y,p2x,p2y,hasmouse*2)
uiz_containend()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
