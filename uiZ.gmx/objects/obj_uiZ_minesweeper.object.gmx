<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///#define uiZ
//#sprite images
//#spritenum 4
//#objectversion 1.0
uiz_objinit()
sizex=8//v//size x//
sizey=8//v//size y//
minegrid=-1;
mines=10//v//number of mines//
color=c_white//c//color blend//
sprite=spr_uiZ_win31_minetiles//p//sprite to use//
selx=0;
sely=0;
won=-1
markings=0;
openings=0;
update=false;
updated=false;
uiz_minesweeper_reset(id)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_endobject()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_beginstep()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///make the whole game run
update=false;
updated=false;
kmouseover=uiz_mouse_isonobject_leftcheck(id)
if kmouseover&gt;0 and won=-1 then{
var mx=uiz_getmouse_x()-rx;
var my=uiz_getmouse_y()-ry;
selx=mx div (width/sizex);
sely=my div (height/sizey);
if mouse_check_button_released(mb_right) then{
//mark
var szx=ds_grid_width(minegrid);
var szy=ds_grid_height(minegrid);
if ds_exists(minegrid,ds_type_grid) and szx&gt;=selx and szy&gt;=sely then{
var m=minegrid[# selx,sely];
update=true;
if ((m &amp; 32)&gt;&gt;5)=0 then{
minegrid[# selx,sely]=m | 32;
markings++;
}else{
minegrid[# selx,sely]=m &amp; ~32;
markings--;
}
}
}
if kmouseover=4 then{
//enable bit
var szx=ds_grid_width(minegrid);
var szy=ds_grid_height(minegrid);
if ds_exists(minegrid,ds_type_grid) and szx&gt;=selx and szy&gt;=sely then{
var m=minegrid[# selx,sely];
if ((m &amp; 32)&gt;&gt;5)=0 and ((m &amp; 16)&gt;&gt;4)=0 then{
if m mod 8=0 then{won=0;updated=true;}
update=true;
minegrid[# selx,sely]=m | 16;
openings++;
//search around cell for empty grid spaces to enable (very optimized diamond shape search script)
var squaresize=1
var maxsquaresize=sqr(max(szx,szy))
while(squaresize&lt;maxsquaresize){
//squaresize=2
//topleft
for(var i=max(0,-selx+squaresize,sely-szy+1);i&lt;min(squaresize,sely+1,szx+squaresize-selx);i++){
var dx=selx-squaresize+i;
var dy=sely-i;
var m=minegrid[# dx,dy];
if dx+1&lt;szx then{var r=minegrid[# dx+1,dy];}else{var r=0;}
if dy+1&lt;szy then{var b=minegrid[# dx,dy+1];}else{var b=0;}
if dx-1&gt;=0 then{var l=minegrid[# dx-1,dy];}else{var l=0;}
if dy-1&gt;=0 then{var t=minegrid[# dx,dy-1];}else{var t=0;}
if dx+1&lt;szx and dy+1&lt;szy then{var rb=minegrid[# dx+1,dy+1];}else{var rb=0;}
if dx+1&lt;szx and dy-1 then{var rt=minegrid[# dx+1,dy-1];}else{var rt=0;}
if dx-1&gt;=0 and dy+1&lt;szy then{var lb=minegrid[# dx-1,dy+1];}else{var lb=0;}
if dx-1&gt;=0 and dy-1 then{var lt=minegrid[# dx-1,dy-1];}else{var lt=0;}
if ((m &amp; 16)&gt;&gt;4)=0 and ((m &amp; 32)&gt;&gt;5)=0 and ((((r &amp; 16)&gt;&gt;4)=1 and (r mod 8)=1) or (((b &amp; 16)&gt;&gt;4)=1 and (b mod 8)=1) or (((l &amp; 16)&gt;&gt;4)=1 and (l mod 8)=1) or (((t &amp; 16)&gt;&gt;4)=1 and (t mod 8)=1) 
or (((rb &amp; 16)&gt;&gt;4)=1 and (rb mod 8)=1) or (((rt &amp; 16)&gt;&gt;4)=1 and (rt mod 8)=1) or (((lb &amp; 16)&gt;&gt;4)=1 and (lb mod 8)=1) or (((lt &amp; 16)&gt;&gt;4)=1 and (lt mod 8)=1)
)then{minegrid[# dx,dy]=m | 16; openings++}
}
//topright
for(var i=max(0,-sely+squaresize);i&lt;min(squaresize,szx-selx,szy-sely+squaresize);i++){
var dx=selx+i;
var dy=sely-squaresize+i;
var m=minegrid[# dx,dy];
if dx+1&lt;szx then{var r=minegrid[# dx+1,dy];}else{var r=0;}
if dy+1&lt;szy then{var b=minegrid[# dx,dy+1];}else{var b=0;}
if dx-1&gt;=0 then{var l=minegrid[# dx-1,dy];}else{var l=0;}
if dy-1&gt;=0 then{var t=minegrid[# dx,dy-1];}else{var t=0;}
if dx+1&lt;szx and dy+1&lt;szy then{var rb=minegrid[# dx+1,dy+1];}else{var rb=0;}
if dx+1&lt;szx and dy-1 then{var rt=minegrid[# dx+1,dy-1];}else{var rt=0;}
if dx-1&gt;=0 and dy+1&lt;szy then{var lb=minegrid[# dx-1,dy+1];}else{var lb=0;}
if dx-1&gt;=0 and dy-1 then{var lt=minegrid[# dx-1,dy-1];}else{var lt=0;}
if ((m &amp; 16)&gt;&gt;4)=0 and ((m &amp; 32)&gt;&gt;5)=0 and ((((r &amp; 16)&gt;&gt;4)=1 and (r mod 8)=1) or (((b &amp; 16)&gt;&gt;4)=1 and (b mod 8)=1) or (((l &amp; 16)&gt;&gt;4)=1 and (l mod 8)=1) or (((t &amp; 16)&gt;&gt;4)=1 and (t mod 8)=1) 
or (((rb &amp; 16)&gt;&gt;4)=1 and (rb mod 8)=1) or (((rt &amp; 16)&gt;&gt;4)=1 and (rt mod 8)=1) or (((lb &amp; 16)&gt;&gt;4)=1 and (lb mod 8)=1) or (((lt &amp; 16)&gt;&gt;4)=1 and (lt mod 8)=1)
)then{minegrid[# dx,dy]=m | 16; openings++}
}
//bottomright
for(var i=max(0,-szx+selx+squaresize,-szx+selx+squaresize+1);i&lt;min(squaresize,squaresize+selx+1,szy-sely);i++){
var dx=selx+squaresize-i;
var dy=sely+i;
var m=minegrid[# dx,dy];
if dx+1&lt;szx then{var r=minegrid[# dx+1,dy];}else{var r=0;}
if dy+1&lt;szy then{var b=minegrid[# dx,dy+1];}else{var b=0;}
if dx-1&gt;=0 then{var l=minegrid[# dx-1,dy];}else{var l=0;}
if dy-1&gt;=0 then{var t=minegrid[# dx,dy-1];}else{var t=0;}
if dx+1&lt;szx and dy+1&lt;szy then{var rb=minegrid[# dx+1,dy+1];}else{var rb=0;}
if dx+1&lt;szx and dy-1 then{var rt=minegrid[# dx+1,dy-1];}else{var rt=0;}
if dx-1&gt;=0 and dy+1&lt;szy then{var lb=minegrid[# dx-1,dy+1];}else{var lb=0;}
if dx-1&gt;=0 and dy-1 then{var lt=minegrid[# dx-1,dy-1];}else{var lt=0;}
if ((m &amp; 16)&gt;&gt;4)=0 and ((m &amp; 32)&gt;&gt;5)=0 and ((((r &amp; 16)&gt;&gt;4)=1 and (r mod 8)=1) or (((b &amp; 16)&gt;&gt;4)=1 and (b mod 8)=1) or (((l &amp; 16)&gt;&gt;4)=1 and (l mod 8)=1) or (((t &amp; 16)&gt;&gt;4)=1 and (t mod 8)=1) 
or (((rb &amp; 16)&gt;&gt;4)=1 and (rb mod 8)=1) or (((rt &amp; 16)&gt;&gt;4)=1 and (rt mod 8)=1) or (((lb &amp; 16)&gt;&gt;4)=1 and (lb mod 8)=1) or (((lt &amp; 16)&gt;&gt;4)=1 and (lt mod 8)=1)
)then{minegrid[# dx,dy]=m | 16; openings++}
}
//bottomleft
for(var i=max(0,-szx+selx+1,-szy+sely+squaresize+1);i&lt;min(squaresize,selx+1,squaresize+selx+1);i++){
var dx=selx-i;
var dy=sely+squaresize-i;
var m=minegrid[# dx,dy];
if dx+1&lt;szx then{var r=minegrid[# dx+1,dy];}else{var r=0;}
if dy+1&lt;szy then{var b=minegrid[# dx,dy+1];}else{var b=0;}
if dx-1&gt;=0 then{var l=minegrid[# dx-1,dy];}else{var l=0;}
if dy-1&gt;=0 then{var t=minegrid[# dx,dy-1];}else{var t=0;}
if dx+1&lt;szx and dy+1&lt;szy then{var rb=minegrid[# dx+1,dy+1];}else{var rb=0;}
if dx+1&lt;szx and dy-1 then{var rt=minegrid[# dx+1,dy-1];}else{var rt=0;}
if dx-1&gt;=0 and dy+1&lt;szy then{var lb=minegrid[# dx-1,dy+1];}else{var lb=0;}
if dx-1&gt;=0 and dy-1 then{var lt=minegrid[# dx-1,dy-1];}else{var lt=0;}
if ((m &amp; 16)&gt;&gt;4)=0 and ((m &amp; 32)&gt;&gt;5)=0 and ((((r &amp; 16)&gt;&gt;4)=1 and (r mod 8)=1) or (((b &amp; 16)&gt;&gt;4)=1 and (b mod 8)=1) or (((l &amp; 16)&gt;&gt;4)=1 and (l mod 8)=1) or (((t &amp; 16)&gt;&gt;4)=1 and (t mod 8)=1) 
or (((rb &amp; 16)&gt;&gt;4)=1 and (rb mod 8)=1) or (((rt &amp; 16)&gt;&gt;4)=1 and (rt mod 8)=1) or (((lb &amp; 16)&gt;&gt;4)=1 and (lb mod 8)=1) or (((lt &amp; 16)&gt;&gt;4)=1 and (lt mod 8)=1)
)then{minegrid[# dx,dy]=m | 16; openings++}
}
squaresize++
}
if openings&gt;=szx*szy-mines then{won=1;updated=true;}//check if won
}
}
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_endobject()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_endobject()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if uiz_cntn() then{
if ds_exists(minegrid,ds_type_grid) then{
var szx=ds_grid_width(minegrid);
var szy=ds_grid_height(minegrid);
var scx=(width/sprite_get_width(sprite))/sizex;
var scy=(height/sprite_get_height(sprite))/sizey;
var wx=width/szx;
var wy=height/szy;
var celltype,cellimage,cellenabled,cellflagged,m;
for(var i=0;i&lt;szx;i++){
for(var e=0;e&lt;szy;e++){
m=minegrid[# i,e];
celltype=m mod 8;
//cellenabled=(m mod 16)div 8;
//cellflagged=(m mod 32)div 16;
cellenabled=(m &amp; 16)&gt;&gt;4;
cellflagged=(m &amp; 32)&gt;&gt;5;
//sdbm(cellenabled)
if cellenabled=true or won!=-1 then{

if celltype=0 then{
if selx=i and sely=e then{cellimage=5}else{cellimage=4}
}else{
cellimage=5+celltype

}

}else{
if cellflagged=false then{
if selx=i and sely=e then{cellimage=1}else{cellimage=0}
}else{if selx=i and sely=e then{cellimage=3}else{cellimage=2}}
}

draw_sprite_ext(sprite,cellimage,rx+wx*i,ry+wy*e,scx,scy,0,color,alpha)

}}

}
uiz_containend()
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
