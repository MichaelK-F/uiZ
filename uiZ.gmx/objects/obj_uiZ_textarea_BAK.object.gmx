<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///#define uiZ
//#sprite images
//#spritenum 24
//#objectversion 1.0
uiz_objinit()
value=""//s//value//
qstr=""
font=-1//f//font//
qstrpos=0;
pline=0;
liney=0;
vpos=0;

selp1=0;
selp2=0;
qstr_selp1=0;
qstr_selp2=0;
qstr_selpmin=0;
qstr_selpmax=0;

selpmin=0;
selpmax=0;
selp1line=0;
selp2line=0;
selpminline=0;
selpmaxline=0;
selpx1=0;
selpx2=0;
selpxmin=0;
selpxmax=0;
selpline="";
selplineBeg="";
selplineMidEnd="";
qstr_lineBeg="";
qstr_lineMidEnd="";
lsz=0;
hasmouse=false;
hasselection=true;
pos=0;
posx=0;
oldposx=0;
posline=0;
//enterpos=1;
textcolor=c_black//c//text color//
selecttextcolor=c_white//c//selection text color//
selectbackcolor=c_blue//c//selection background color//

typing=false;
lastkeyboard_key=0;
resetpos=false;
changesign=false;
whatsign=""
len=0;
vadpos=0;
startposline=0;

scrollbarsize=0.15//v//scrollbarsize//
scrollbarsizetype=dp//z//scrollbarsizetype//
scrollbarsprite=spr_uiZ_scrollbar//p//sprite//
scrollbarcolor=c_white//c//color//
scrollbartexturemode=uiz_texturemode_fill//t//texturemode//
scroll=-1
lastscroll=0;
scrolllines=100
scrollspeed=1//v//scrollspeed//
doscroll=false;
lastbegscrpos=0
debugText="";

forceMultilineDraw=false;

accountspeed=1//v//rapid mode count time//
accbetween=0.000001//v//rapid mode speed//

typeanimationin=uiz_exponential_in//a//type animation in//
typeanimationout=uiz_exponential_in//a//type animation out//
countspeed=1//v//type animation time//
count=0;
typecolor=c_black//c//type indicater color//
cursorwidth=3//c//type indicater thickness//


hasbackground=true;
texturescript=uiz_back_circlestitch//i//texturescript//
texturescript_over=-1//i//texturescript over//
texturescript_in=-1//i//texturescript in//
texturescript_out=-1//i//texturescript out//

sprite_normal=spr_uiZ_border1//p//sprite normal//
color_normal=c_white//c//color normal//
margin_normal=5//v//margin normal//
sprite_texturemode=uiz_texturemode_fill//t//texturemode normal
border_texturemode=-1//t//texturemode border//

sprite_over=spr_uiZ_border1_over//p//sprite over//
color_over=-1//c//color over//
margin_over=-1//v//margin over//

sprite_in=spr_uiZ_border1_in//p//sprite in//
color_in=-1//c//color in//
margin_in=-1//v//margin in//

sprite_out=spr_uiZ_border1_in//p//sprite out//
color_out=-1//c//color out//
margin_out=-1//v//margin out//
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_endobject()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///check the typing
//sdbm("textarea stepping")
if global.systemsupportskeyboard = true then {

    
    if hasselection!=0 or pos&lt;=0 then{
    typing=false;
        uiz_updater_unstep();
        uiz_typecursor_deregister();
        exit;
    }else{
    len = string_length(value)


    //keyboard shortcuts, like copy, paste, ... 
    if keyboard_check(vk_control) then {
        //dbm(keyboard_key)
        if lastkeyboard_key &gt; 0 and keyboard_check_released(lastkeyboard_key) then {
            //dbm(lastkeyboard_key)
            //sdbm(lastkeyboard_key)
            switch (lastkeyboard_key) {
                case 50: //2/@
                    changesign = 1;
                    whatsign = "@";
                    break;
                case 55: //7/&amp;
                    changesign = 1;
                    whatsign = "&amp;";
                    break;
                case 188: //,/&lt;
                    changesign = 1;
                    whatsign = ",";
                    break;
                case 222: //'/"
                    changesign = 1;
                    whatsign = "'";
                    break;
                case 191: ////?
                    changesign = 1;
                    whatsign = "/";
                    break;
                case 65: //a
                    //dbm("hi!")
                    hasselection = true
                    selp1 = 0
                    selp2 = len + 1
                    selpxmin = 0;
                    selpmin = selp1;
                    selpmax = selp2;
                    selpminline = 0;
                    qlen = string_length(qstr)
                    selpmaxline = 0;
                    var lastat = 1;
                    for (var i = 1; i &lt;= qlen; i++) {
                        if string_char_at(qstr, i) = "#"
                        or string_char_at(qstr, i) = chr($0A) then {
                            selpmaxline += 1;
                            var lastat = i;
                        }
                    }
                    //sdbm(uiz_string_copy(qstr,lastat+1,qlen))
                    selpxmax = string_width(uiz_string_copy(qstr, lastat + 1, qlen));


                    //resetpos=true;
                    break;
                case 86: //v, paste
                    //sdbm("hi paste!: ",clipboard_get_text())
                    if hasselection = 1 then {
                        uiz_textarea_deletesel()
                    }
                    value = string_copy(value, 0, pos) + clipboard_get_text() + string_copy(value, pos + 1, len)
                    uiz_textarea_qstr()
                    len = string_length(value)
                    pos += string_length(clipboard_get_text())
                    uiz_textarea_resetpos()
                    break;
                case 88: //x, cut
                    if hasselection = 1 then {
                        clipboard_set_text(uiz_string_copy(value, selpmin + 1, selpmax))
                        uiz_textarea_deletesel()
                    }
                    /*else{
                    clipboard_set_text(value)
                    value=""
                    }*/
                    break;
                case 67: //c, copy
                    if hasselection = 1 then {
                        clipboard_set_text(uiz_string_copy(value, selpmin + 1, selpmax))
                    } else {
                        clipboard_set_text(value)
                    }
                    break;
            }
        }
    } else {
        //control isn't pressed
        if keyboard_check(keyboard_key) and!(keyboard_key = 0) then {
            account = min(account + (1 / (accountspeed * room_speed)), 1)
        } else {
            account = 0
        }
        if lastkeyboard_key != keyboard_key then {
            account = 0
        }
        if (keyboard_check_pressed(keyboard_key) or account = 1) and!(keyboard_key = 0) then {
            account = max(account - ((accbetween * room_speed)), 0)




            if hasselection = 1 then {
                switch (keyboard_key) {
                    case vk_lshift:
                    case vk_rshift:
                    case vk_shift:
                        break;
                    case vk_left:
                        if keyboard_check(vk_shift) then {
                            if selp2 &gt; 0 then {
                                selp2--;
                            }

                            uiz_textarea_resetsel()
                            if selpmax - selpmin = 0 then {
                                if selpmin &gt; 0 then {
                                    pos = selpmin;
                                    uiz_textarea_resetpos()
                                }
                                hasselection = false;
                                selp1 = 0;
                                selp2 = 0;
                                selpmin = 0;
                                selpmax = 0;
                                selpminline = 0;
                                selpmaxline = 0;
                                selpxmin = 0;
                                selpxmax = 0;
                            }
                        } else {
                            if selpmin &gt; 0 then {
                                pos = selpmin;
                                uiz_textarea_resetpos()
                            }
                            hasselection = false;
                            selp1 = 0;
                            selp2 = 0;
                            selpmin = 0;
                            selpmax = 0;
                            selpminline = 0;
                            selpmaxline = 0;
                            selpxmin = 0;
                            selpxmax = 0;

                        }

                        break;
                    case vk_right:
                        if keyboard_check(vk_shift) then {
                            if selp2 &lt; len then {
                                selp2++;
                            }

                            uiz_textarea_resetsel()
                            if selpmax - selpmin = 0 then {
                                if selpmin &gt; 0 then {
                                    pos = selpmax;
                                    uiz_textarea_resetpos()
                                }
                                hasselection = false;
                                selp1 = 0;
                                selp2 = 0;
                                selpmin = 0;
                                selpmax = 0;
                                selpminline = 0;
                                selpmaxline = 0;
                                selpxmin = 0;
                                selpxmax = 0;
                            }
                        } else {
                            if selpmin &gt; 0 then {
                                pos = selpmax;
                                uiz_textarea_resetpos()
                            }
                            hasselection = false;
                            selp1 = 0;
                            selp2 = 0;
                            selpmin = 0;
                            selpmax = 0;
                            selpminline = 0;
                            selpmaxline = 0;
                            selpxmin = 0;
                            selpxmax = 0;

                        }

                        break;




                    case vk_up:
                        if keyboard_check(vk_shift) then {
                            pos = selp2
                            uiz_textarea_resetpos()
                            lsz = string_height("ƒF|⎲}g")
                            var lan = string_length(qstr)
                            //check max lines
                            var lines = 0;
                            for (var i = 0; i &lt;= lan; i++) {
                                if string_char_at(qstr, i) = "#"
                                or string_char_at(qstr, i) = chr($0A) then {
                                    lines++
                                }
                            }
                            var liney = clamp(posline - 1, 0, lines)
                            posline = liney
                            pline = 0;
                            var plinechar = 1;
                            //loop trough qstr to find the line

                            for (var i = 0; i &lt;= lan; i++) {
                                //count lines
                                if string_char_at(qstr, i) = "#"
                                or string_char_at(qstr, i) = chr($0A) then {
                                    pline++;
                                    plinechar = i + 1;
                                }
                                //if on right line
                                if pline = liney then {
                                    //get w of current char
                                    if i = 0 then {
                                        var w = 0
                                    } else {
                                        var w = string_width(uiz_string_copy(qstr, plinechar, i));
                                    }
                                    var sta = "a"
                                    if i &lt; lan then {
                                        sta = string_char_at(qstr, i + 1)
                                    }
                                    if (i = 0 and posx &lt; string_width(string_char_at(qstr, 1)) / 2) or w &gt; posx or sta = "#"
                                    or sta = chr($0A) then {
                                        qstrpos = i - 1;
                                        posx = string_width(uiz_string_copy(qstr, plinechar, i - 1))
                                        break;
                                    }
                                }
                            }
                            uiz_textarea_qstrtovalue()
                            selp2 = pos;
                            uiz_textarea_resetsel()
                        } else {
                            if selp2 &gt; 0 then {
                                pos = selp2;
                                uiz_textarea_resetpos()
                            }
                            hasselection = false;
                            selp1 = 0;
                            selp2 = 0;
                            selpmin = 0;
                            selpmax = 0;
                            selpminline = 0;
                            selpmaxline = 0;
                            selpxmin = 0;
                            selpxmax = 0;

                            lsz = string_height("ƒF|⎲}g")
                            var lan = string_length(qstr)
                            //check max lines
                            var lines = 0;
                            for (var i = 0; i &lt;= lan; i++) {
                                if string_char_at(qstr, i) = "#"
                                or string_char_at(qstr, i) = chr($0A) then {
                                    lines++
                                }
                            }
                            var liney = clamp(posline - 1, 0, lines)
                            posline = liney
                            pline = 0;
                            var plinechar = 1;
                            //loop trough qstr to find the line

                            for (var i = 0; i &lt;= lan; i++) {
                                //count lines
                                if string_char_at(qstr, i) = "#"
                                or string_char_at(qstr, i) = chr($0A) then {
                                    pline++;
                                    plinechar = i + 1;
                                }
                                //if on right line
                                if pline = liney then {
                                    //get w of current char
                                    if i = 0 then {
                                        var w = 0
                                    } else {
                                        var w = string_width(uiz_string_copy(qstr, plinechar, i));
                                    }
                                    var sta = "a"
                                    if i &lt; lan then {
                                        sta = string_char_at(qstr, i + 1)
                                    }
                                    if (i = 0 and posx &lt; string_width(string_char_at(qstr, 1)) / 2) or w &gt; posx or sta = "#"
                                    or sta = chr($0A) then {
                                        qstrpos = i - 1;
                                        posx = string_width(uiz_string_copy(qstr, plinechar, i - 1))
                                        break;
                                    }
                                }
                            }
                            uiz_textarea_qstrtovalue()

                        }
                        break; //up




                    case vk_down:
                        if keyboard_check(vk_shift) then {
                            pos = selp2
                            uiz_textarea_resetpos()
                            lsz = string_height("ƒF|⎲}g")
                            var lan = string_length(qstr)
                            //check max lines
                            var lines = 0;
                            for (var i = 0; i &lt;= lan; i++) {
                                if string_char_at(qstr, i) = "#"
                                or string_char_at(qstr, i) = chr($0A) then {
                                    lines++
                                }
                            }
                            var liney = clamp(posline + 1, 0, lines)
                            posline = liney
                            pline = 0;
                            var plinechar = 1;
                            //loop trough qstr to find the line

                            for (var i = 0; i &lt;= lan; i++) {
                                //count lines
                                if string_char_at(qstr, i) = "#"
                                or string_char_at(qstr, i) = chr($0A) then {
                                    pline++;
                                    plinechar = i + 1;
                                }
                                //if on right line
                                if pline = liney then {
                                    //get w of current char
                                    if i = 0 then {
                                        var w = 0
                                    } else {
                                        var w = string_width(uiz_string_copy(qstr, plinechar, i));
                                    }
                                    var sta = "a"
                                    if i &lt; lan then {
                                        sta = string_char_at(qstr, i + 1)
                                    }
                                    if (i = 0 and posx &lt; string_width(string_char_at(qstr, 1)) / 2) or w &gt; posx or sta = "#"
                                    or sta = chr($0A) then {
                                        qstrpos = i - 1;
                                        posx = string_width(uiz_string_copy(qstr, plinechar, i - 1))
                                        break;
                                    }
                                }
                            }
                            uiz_textarea_qstrtovalue()
                            selp2 = pos;
                            uiz_textarea_resetsel()
                        } else {
                            if selp2 &gt; 0 then {
                                pos = selp2;
                                uiz_textarea_resetpos()
                            }
                            hasselection = false;
                            selp1 = 0;
                            selp2 = 0;
                            selpmin = 0;
                            selpmax = 0;
                            selpminline = 0;
                            selpmaxline = 0;
                            selpxmin = 0;
                            selpxmax = 0;

                            lsz = string_height("ƒF|⎲}g")
                            var lan = string_length(qstr)
                            //check max lines
                            var lines = 0;
                            for (var i = 0; i &lt;= lan; i++) {
                                if string_char_at(qstr, i) = "#"
                                or string_char_at(qstr, i) = chr($0A) then {
                                    lines++
                                }
                            }
                            var liney = clamp(posline + 1, 0, lines)
                            posline = liney
                            pline = 0;
                            var plinechar = 1;
                            //loop trough qstr to find the line

                            for (var i = 0; i &lt;= lan; i++) {
                                //count lines
                                if string_char_at(qstr, i) = "#"
                                or string_char_at(qstr, i) = chr($0A) then {
                                    pline++;
                                    plinechar = i + 1;
                                }
                                //if on right line
                                if pline = liney then {
                                    //get w of current char
                                    if i = 0 then {
                                        var w = 0
                                    } else {
                                        var w = string_width(uiz_string_copy(qstr, plinechar, i));
                                    }
                                    var sta = "a"
                                    if i &lt; lan then {
                                        sta = string_char_at(qstr, i + 1)
                                    }
                                    if (i = 0 and posx &lt; string_width(string_char_at(qstr, 1)) / 2) or w &gt; posx or sta = "#"
                                    or sta = chr($0A) then {
                                        qstrpos = i - 1;
                                        posx = string_width(uiz_string_copy(qstr, plinechar, i - 1))
                                        break;
                                    }
                                }
                            }
                            uiz_textarea_qstrtovalue()

                        }
                        break; //down

                    case vk_home:
                        if keyboard_check(vk_shift) then {
                            var qslen = string_length(qstr);
                            var pline = 0;
                            for (var i = 0; i &lt;= qslen; i++) {
                                if i = qslen then {
                                    qstrpos = 0;
                                } else {
                                    var sca = string_char_at(qstr, i)
                                    if i &gt; 0 and(sca = "#"
                                        or sca = chr($0A)) then {
                                        pline++;
                                    }
                                    if pline = selp2line then {
                                        qstrpos = i
                                        break;
                                    }
                                }
                            }
                            uiz_textarea_qstrtovalue()
                            selp2 = pos;
                            uiz_textarea_resetsel()


                        } else {

                            var qslen = string_length(qstr);
                            var pline = 0;
                            for (var i = 0; i &lt;= qslen; i++) {
                                if i = qslen then {
                                    qstrpos = 0;
                                } else {
                                    var sca = string_char_at(qstr, i)
                                    if i &gt; 0 and(sca = "#"
                                        or sca = chr($0A)) then {
                                        pline++;
                                    }
                                    if pline = selp2line then {
                                        qstrpos = i
                                        break;
                                    }
                                }
                            }
                            uiz_textarea_qstrtovalue()


                            hasselection = false;
                            selp1 = 0;
                            selp2 = 0;
                            selpmin = 0;
                            selpmax = 0;
                            selpminline = 0;
                            selpmaxline = 0;
                            selpxmin = 0;
                            selpxmax = 0;

                        }

                        break; //home

                    case vk_end:

                        if keyboard_check(vk_shift) then {
                            //insert
                            var qslen = string_length(qstr);
                            var pline = 0;
                            for (var i = 1; i &lt;= qslen; i++) {
                                if i = qslen then {
                                    qstrpos = qslen;
                                } else {
                                    var sca = string_char_at(qstr, i)
                                    if sca = "#"
                                    or sca = chr($0A) then {
                                        pline++;
                                    }
                                    if pline = posline + 1 then {
                                        if string_char_at(qstr, i - 1) = chr($0D) then {
                                            qstrpos = i - 2
                                        } else {
                                            qstrpos = i - 1
                                        }
                                        break;
                                    }
                                }
                            }
                            uiz_textarea_qstrtovalue()
                            selp2 = pos;
                            uiz_textarea_resetsel()


                        } else {

                            //insert
                            var qslen = string_length(qstr);
                            var pline = 0;
                            for (var i = 1; i &lt;= qslen; i++) {
                                if i = qslen then {
                                    qstrpos = qslen;
                                } else {
                                    var sca = string_char_at(qstr, i)
                                    if sca = "#"
                                    or sca = chr($0A) then {
                                        pline++;
                                    }
                                    if pline = posline + 1 then {
                                        if string_char_at(qstr, i - 1) = chr($0D) then {
                                            qstrpos = i - 2
                                        } else {
                                            qstrpos = i - 1
                                        }
                                        break;
                                    }
                                }
                            }
                            uiz_textarea_qstrtovalue()

                            hasselection = false;
                            selp1 = 0;
                            selp2 = 0;
                            selpmin = 0;
                            selpmax = 0;
                            selpminline = 0;
                            selpmaxline = 0;
                            selpxmin = 0;
                            selpxmax = 0;

                        }

                        break; //end
                    case vk_backspace:
                    case vk_delete:

                        uiz_textarea_deletesel()

                        break;
                    case vk_enter:
                        uiz_textarea_deletesel()
                        if changesign = 1 then {
                            uiz_textarea_addchar(whatsign)
                        } else {
                            uiz_textarea_addchar_c(chr($0D) + chr($0A))
                        }
                        whatsign = ""
                        changesign = 0

                        break;
                    default:

                        uiz_textarea_deletesel()
                        if keyboard_check(vk_control) or keyboard_check(vk_alt) or(keyboard_key &gt;= 112 and keyboard_key &lt;= 123) or keyboard_key = 174 or keyboard_key = 175 then {} else {
                            if changesign = 1 then {
                                uiz_textarea_addchar_c(uiz_returncharaddon(string_char_at(keyboard_string, string_length(keyboard_string)), whatsign))
                            } else {
                                uiz_textarea_addchar(string_char_at(keyboard_string, string_length(keyboard_string)))
                            }
                            whatsign = ""
                            changesign = 0
                        }

                        break;
                }




            } else {
                //!hasselection



                switch (keyboard_key) {
                    case vk_up:

                        lsz = string_height("ƒF|⎲}g")
                        var lan = string_length(qstr)
                        //check max lines
                        var lines = 0;
                        for (var i = 0; i &lt;= lan; i++) {
                            if string_char_at(qstr, i) = "#"
                            or string_char_at(qstr, i) = chr($0A) then {
                                lines++
                            }
                        }
                        var liney = clamp(posline - 1, 0, lines)
                        posline = liney
                        pline = 0;
                        var plinechar = 1;
                        //loop trough qstr to find the line

                        for (var i = 0; i &lt;= lan; i++) {
                            //count lines
                            if string_char_at(qstr, i) = "#"
                            or string_char_at(qstr, i) = chr($0A) then {
                                pline++;
                                plinechar = i + 1;
                            }
                            //if on right line
                            if pline = liney then {
                                //get w of current char
                                if i = 0 then {
                                    var w = 0
                                } else {
                                    var w = string_width(uiz_string_copy(qstr, plinechar, i));
                                }
                                var sta = "a"
                                if i &lt; lan then {
                                    sta = string_char_at(qstr, i + 1)
                                }
                                if (i = 0 and posx &lt; string_width(string_char_at(qstr, 1)) / 2) or w &gt; posx or sta = "#"
                                or sta = chr($0A) then {
                                    qstrpos = i - 1;
                                    posx = string_width(uiz_string_copy(qstr, plinechar, i - 1))
                                    break;
                                }
                            }
                        }
                        uiz_textarea_qstrtovalue()
                        break; //up

                    case vk_down:

                        lsz = string_height("ƒF|⎲}g")
                        var lan = string_length(qstr)
                        //check max lines
                        var lines = 0;
                        for (var i = 0; i &lt;= lan; i++) {
                            if string_char_at(qstr, i) = "#"
                            or string_char_at(qstr, i) = chr($0A) then {
                                lines++
                            }
                        }
                        var liney = clamp(posline + 1, 0, lines)
                        posline = liney
                        pline = 0;
                        var plinechar = 1;
                        //loop trough qstr to find the line

                        for (var i = 0; i &lt;= lan; i++) {
                            //count lines
                            if string_char_at(qstr, i) = "#"
                            or string_char_at(qstr, i) = chr($0A) then {
                                pline++;
                                plinechar = i + 1;
                            }
                            //if on right line
                            if pline = liney then {
                                //get w of current char
                                if i = 0 then {
                                    var w = 0
                                } else {
                                    var w = string_width(uiz_string_copy(qstr, plinechar, i));
                                }
                                var sta = "a"
                                if i &lt; lan then {
                                    sta = string_char_at(qstr, i + 1)
                                }
                                if (i = 0 and posx &lt; string_width(string_char_at(qstr, 1)) / 2) or w &gt; posx or sta = "#"
                                or sta = chr($0A) then {
                                    qstrpos = i - 1;
                                    posx = string_width(uiz_string_copy(qstr, plinechar, i - 1))
                                    break;
                                }
                            }
                        }
                        uiz_textarea_qstrtovalue()
                        break; //down


                    case vk_left:
                        if keyboard_check(vk_shift) then {
                            //if hasselection=0 then{
                            if pos &gt; 0 then {
                                hasselection = 1
                                selp1 = pos
                                selp2 = pos - 1
                                selpmin = pos
                                selpmax = pos - 1
                                uiz_textarea_resetsel()
                            }

                        } else {
                            hasselection = false;
                        }
                        if pos &gt; 0 then {
                            pos--;
                            uiz_textare_snappos_left() uiz_textarea_resetpos()
                        }
                        break;
                    case vk_right:
                        if keyboard_check(vk_shift) then {
                            //if hasselection=0 then{
                            if pos &lt; len then {
                                hasselection = 1;
                                selp1 = pos
                                selp2 = pos + 1
                                selpmin = pos
                                selpmax = pos + 1
                                uiz_textarea_resetsel()
                            }

                        } else {
                            hasselection = false
                        }
                        if pos &lt; len then {
                            pos++;
                            uiz_textare_snappos_right() uiz_textarea_resetpos()
                        }
                        break;


                    case vk_backspace:
                        uiz_textarea_doBackspace(0);
                        break;
                    case vk_delete:
                        uiz_textarea_doBackspace(1);
                        break;
                    case 222:
                        if changesign = 1 then {
                            changesign = 0
                            //uiz_stringbox_addchar()
                            //uiz_stringbox_addchar()
                            uiz_textarea_addchars(whatsign + whatsign, 2)

                        } else {
                            changesign = 1
                        }
                        if keyboard_check(vk_shift) then {
                            whatsign = '"'
                        } else {
                            whatsign = "'"
                        }
                        break;
                    case vk_tab:
                        break; //tab
                    case vk_shift:
                        break; //shift
                    case 27:
                        break; //esc
                    case 144:
                        break; //numlock
                    case 45:
                        break; //insert
                    case 19:
                        break; //page break
                    case 35:
                        var oldpos = pos
                        var qslen = string_length(qstr);
                        var pline = 0;
                        for (var i = 1; i &lt;= qslen; i++) {
                            if i = qslen then {
                                qstrpos = qslen;
                            } else {
                                var sca = string_char_at(qstr, i)
                                if sca = "#"
                                or sca = chr($0A) then {
                                    pline++;
                                }
                                if pline = posline + 1 then {
                                    if string_char_at(qstr, i - 1) = chr($0D) then {
                                        qstrpos = i - 2
                                    } else {
                                        qstrpos = i - 1
                                    }
                                    break;
                                }
                            }
                        }
                        uiz_textarea_qstrtovalue()



                        if keyboard_check(vk_shift) then {
                            hasselection = 1
                            selp1 = oldpos
                            selp2 = pos
                            selpmin = oldpos
                            selpmax = pos
                            uiz_textarea_resetsel()


                        }




                        break; //end
                    case 36:
                        var oldpos = pos;
                        var qslen = string_length(qstr);
                        var pline = 0;
                        for (var i = 0; i &lt;= qslen; i++) {
                            if i = qslen then {
                                qstrpos = 0;
                            } else {
                                var sca = string_char_at(qstr, i)
                                if i &gt; 0 and(sca = "#"
                                    or sca = chr($0A)) then {
                                    pline++;
                                }
                                if pline = posline then {
                                    qstrpos = i
                                    break;
                                }
                            }
                        }
                        //sdbm(uiz_string_copy(qstr,1,qstrpos))
                        uiz_textarea_qstrtovalue()

                        if keyboard_check(vk_shift) then {
                            hasselection = 1
                            selp1 = oldpos
                            selp2 = pos
                            selpmin = pos
                            selpmax = oldpos
                            uiz_textarea_resetsel()


                        }

                        break; //home
                    case 33:
                        break; //pg up
                    case 34:
                        break; //pg down
                    case 160:
                    case 161:
                        break;
                    case vk_enter:
                        if changesign = 1 then {
                            uiz_textarea_addchar(whatsign)
                        } else {
                            uiz_textarea_addchar_c(chr($0D) + chr($0A))
                        }
                        whatsign = ""
                        changesign = 0
                        break;
                    default:

                        if keyboard_check(vk_control) or keyboard_check(vk_alt) or(keyboard_key &gt;= 112 and keyboard_key &lt;= 123) or keyboard_key = 174 or keyboard_key = 175 then {} else {
                            if changesign = 1 then {
                                uiz_textarea_addchar_c(uiz_returncharaddon(string_char_at(keyboard_string, string_length(keyboard_string)), whatsign))
                            } else {
                                uiz_textarea_addchar(string_char_at(keyboard_string, string_length(keyboard_string)))
                            }
                            whatsign = ""
                            changesign = 0
                            //}
                            break;
                        }




                }
            }
        }



}
    }


} else {

}
/*
if resetpos=true then{
//transfer value positions to positions in qstr
if hasselection=true then{

}

}
*/
lastkeyboard_key = keyboard_key
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///handle typing animation
if typing=true &amp;&amp; hasselection=false then{
count+=1/(countspeed*room_speed);
if count&gt;=1 then{count=0}
if count&lt;0.5 then{
var anim=uiz_animation_getFunction(count*2,typeanimationin)
}else{
var anim=1-uiz_animation_getFunction((count-0.5)*2,typeanimationout)}
//draw_set_alpha(anim*alpha)
//draw_set_color(typecolor)
uiz_typecursor_setalpha(anim*alpha);
//draw_line(ix+posx,iy+(posline)*lsz,ix+posx,iy+(posline+1)*lsz)
uiz_typecursor_register(ix+posx,iy+(posline)*lsz,ix+posx,iy+(posline+1)*lsz,typecolor,cursorwidth) 
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///handle all selections
//reset qstr if no selection
kmouseover = uiz_mouse_isonobject_leftcheck(id)
//sdbm("now executing ud3 on",id,object_index,object_get_name(object_index),global.mouseover,irandom(10))
scblwidth = uiz_getposx(scrollbarsize, scrollbarsizetype)

//qstr = uiz_gettextlines_contained_infy(value, width)
if string_height(qstr) &gt; height then {
    //qstr = uiz_gettextlines_contained_infy(value, width - scblwidth)
    if doscroll = false then {
        scroll = -1;
    }
    doscroll = true

    //get amount of lines
    var lins = uiz_getlines(qstr)
    //get amount of acces lines
    lsz = string_height("ƒF|⎲}g")
    var linefit = floor(height / lsz)
    scrolllines = lins - linefit
    var fline = min(uiz_positify(scroll), scrolllines)
    var qstrsz = string_length(qstr);
    var linecount = 1;
    vadpos = 1;

    for (var i = 1; i &lt;= qstrsz; i++) {
        var c = string_char_at(qstr, i)
        if c = string_char_at(value, vadpos) then {
            vadpos++;
        }
        if c = "#"
        or c = chr($0A) or fline = 0 then {
            if linecount = fline or fline = 0 then {
                var oldi = i + sign(fline);


                linecount = 0;
                for (var i = oldi; i &lt;= qstrsz; i++) {
                    var c = string_char_at(qstr, i)
                    if c = "#"
                    or c = chr($0A) or(fline = scrolllines and i = qstrsz) then {
                        if linecount &gt;= linefit - 1 or(fline = scrolllines and i = qstrsz) then {
                            lastbegscrpos = oldi
                            qstr = uiz_string_copy(qstr, oldi, i)
                            break;
                        }
                        linecount++;
                    }
                }
                break;
            }

            linecount++;
        }
    }
    //reset pos
    if uiz_positify(scroll) != uiz_positify(lastscroll) then {
        posline = (posline + startposline) - uiz_positify(scroll)
        startposline = uiz_positify(scroll)
        //here
        lastscroll = scroll;
    }
}



if kmouseover &lt;= 1 or kmouseover = 4 and hasmouse = true then {
    hasmouse = false;
    global.mousefrozen = 0;
}
minpos = 0;
//get selection point
if kmouseover &gt; 2 or hasmouse = true then {
    var oldselp2line=selp2line;
    var lastselpdiff = selp2line-selp1line
    //get selection line in qstr
    if font &gt; -1 then {
        draw_set_font(font)
    }
    //setup stuff for loop
    lsz = string_height("ƒF|⎲}g")
    var lan = string_length(qstr)
    //check max lines
    lines = 0;
    for (var i = 0; i &lt;= lan; i++) {
        if string_char_at(qstr, i) = "#"
        or string_char_at(qstr, i) = chr($0A) then {
            lines++
        }
    }
    liney = clamp(floor((uiz_getmouse_y() - iy) / lsz), 0, lines)

    pline = 0;
    var plinechar = 1;
    //loop trough qstr to find the line
    for (var i = 0; i &lt;= lan; i++) {

        qstrpos = 0;
        //check for new line
        //sdbm(string_char_at(qstr,i),ord(string_char_at(qstr,i)))
        if string_char_at(qstr, i) = "#"
        or string_char_at(qstr, i) = chr($0A) then {
            pline++;
            //if string_char_at(qstr,i)="#" then{plinechar=i+1;}else{plinechar=i;}
            plinechar = i + 1
        }
        //if on the right line
        if pline = liney then {
            //sdbm("exec",pline,liney)
            //process the right line.
            if i = 0 then {
                var w = 0
            } else {
                //sdbm(uiz_string_copy(qstr,plinechar,i),i,plinechar)
                var w = string_width(uiz_string_copy(qstr, plinechar, i));
            }
            //sdbm(uiz_string_copy(qstr,plinechar,i))
            var sta = "a"
            if i &lt; lan then {
                sta = string_char_at(qstr, i + 1)
            }
            //if liney=lines and i=lan then{sdbm("exec this",sta,w,uiz_getmouse_x()-sx)}
            if (i = 0 and ((uiz_getmouse_x() - ix) &lt; string_width(string_char_at(qstr, 1)) / 2))
            or (liney = lines and i = lan and w &lt;= uiz_getmouse_x() - ix) 
            or w &gt; uiz_getmouse_x() - ix
            or sta = "#" or sta = chr($0A) or sta = chr($0D) then {
                //if liney=lines and i=lan then{sdbm("exec this")}
                qstrpos = i - 1;
                //select new pos
                //sdbm("uif",kmouseover,slx-scblwidth,scroll)
                if kmouseover = 4 and uiz_getmouse_x() &lt; slx - scblwidth and scroll &lt; 0 then {
                    minpos = 0
                    if i &gt; 1 then {
                        var w2 = string_width(string_char_at(qstr, i))
                        if w + w2 / 2 &gt; uiz_getmouse_x() - sx then {
                            //right side of sign
                            posx = string_width(uiz_string_copy(qstr, plinechar, i-1))
                            //minpos=1;
                            minpos = 0;
                        } else {
                            //left side of sign
                            minpos = 0
                            posx = w-w2
                        }
                    } else {
                        minpos = 0
                        posx = 0
                        w = 0
                    }

                    posline = liney;
                    //startposline=uiz_getlines(string_copy(qstr,1,lastbegscrpos));
                    startposline = uiz_positify(scroll)
                    //sdbm("liney",liney,qstrpos,posx)
                }


                //check for selection
                if kmouseover = 3 and uiz_getmouse_x() &lt; slx - scblwidth and scroll &lt; 0 then {
                    hasmouse = true;
                    global.mousefrozen = true;
                    //sdbm(w,liney)
                    selpx1 = w;
                    selp1line = liney;
                }
                //check second pos of selection
                if hasmouse = true then {
                    //sdbm(w,liney)
                    selpx2 = w;
                    selp2line = liney;
                }
                break;
            }
        }
    }
    //find the right pos inside the value string.

    //vpos=vadpos;
    vpos = 1;
    for (var i = 1; i &lt;= qstrpos; i++) {
        if string_char_at(qstr, i) = string_char_at(value, vpos)
        then {
            //characters match up
            vpos++
        }
    }

    //set selp1, selp2
    if kmouseover = 3 then {
    //sdbm("setting new selpos");
        selp1 = vpos
        qstr_selp1 = qstrpos;
    }
    if hasmouse = true &amp;&amp; selp1!=vpos then {
        selp2 = vpos
        qstr_selp2 = qstrpos;
        //set all the min and max variables to what they are supposed to be.
        hasselection = true
        var fixSelLines=false
        //save old selp values
            var oldselpmin = selpmin
            var oldselpmax = selpmax
            var oldselpxmin = selpxmin
            var oldselpxmax = selpxmax  
            var oldselpmaxline = selpmaxline;
            var oldselpminline = selpminline;
            var oldselpsign = sign(selp2line-selp1line);
        if selp1line &lt; selp2line then {
            //p1 is first
            selpminline = selp1line
            selpmaxline = selp2line
            selpmin = selp1;
            selpmax = selp2;
            qstr_selpmin = qstr_selp1;
            qstr_selpmax = qstr_selp2;
            selpxmin = selpx1;
            selpxmax = selpx2;
            fixSelLines=true;
            //first line
            uiz_updater_FixViews_area_selfmarked(ix+selpx1,iy+(selpminline)*lsz,ilx,iy+(selpminline+1)*lsz)
            var selp2max = max(oldselpmaxline,selpmaxline);
            if selp2max-selp1line&gt;1 then{//a middle line exists
            uiz_updater_FixViews_area_selfmarked(ix,iy+(selpminline+1)*lsz,ilx,iy+(selp2max)*(lsz))
            }
            //last line
            //uiz_updater_FixViews_area_selfmarked(ix,iy+(selpmaxline)*lsz,ix+selpx2,iy+(selpmaxline+1)*lsz)
            uiz_updater_FixViews_area_selfmarked(ix,iy+(selpmaxline)*lsz,ix+max(oldselpxmax,selpxmax),iy+(selp2max+1)*lsz)
            
        } else {
            if selp1line = selp2line then {
                //p1 and p2 on same line
                selpminline = selp1line
                selpmaxline = selp2line
                
                if selpx1 &lt; selpx2 then {
                    selpmin = selp1;
                    selpmax = selp2;
                    qstr_selpmin = qstr_selp1;
                    qstr_selpmax = qstr_selp2;
                    selpxmin = selpx1;
                    selpxmax = selpx2;
                } else {
                    if selpx1 = selpx2 then {
                        hasselection = false;
                    }
                    selpmin = selp2;
                    selpmax = selp1;
                    qstr_selpmin = qstr_selp2;
                    qstr_selpmax = qstr_selp1;
                    selpxmin = selpx2;
                    selpxmax = selpx1;
                }
                selpline=uiz_string_copy(value,selpmin+1,selpmax)
                //selpline=uiz_string_copy(qstr,qstr_selpmin,qstr_selpmax);
                var numOfExtraCharsBefore = selpmin-oldselpmin
                if numOfExtraCharsBefore&gt;0 then{//when chars have been removed from the selection at the beginning of the selection
                    selplineBeg=string_copy(value,selpmin+1-numOfExtraCharsBefore,numOfExtraCharsBefore);
                }else{
                    selplineBeg="";
                }
                var numOfExtraCharsAfter = oldselpmax-selpmax
                if numOfExtraCharsAfter&gt;0 then{//when chars have been removed from the selection at the beginning of the selection
                    selplineMidEnd=string_copy(value,selpmax+1,numOfExtraCharsAfter);
                }else{
                    selplineMidEnd="";
                }
                if selpminline!=oldselpminline || selpmaxline!=oldselpmaxline then{
                    forceMultilineDraw=true;
                    //first line
                    var selp1min = min(oldselpminline,selpminline);
                    var selp2max = max(oldselpmaxline,selpmaxline);
                    //debugText="lastdiff: "+string(lastselpdiff)+" | " +string(irandom(10000));
                    //if lastselpdiff=0 then{
                    //    debugText="Doing diff"+string(irandom(10000));
                    //    uiz_updater_FixViews_area_selfmarked(ix+oldselpxmin,iy+(oldselpminline)*lsz,ix+oldselpxmax,iy+(oldselpminline+1)*lsz)
                    //}
                    if oldselpsign=-1 then{
                    //if coming from top
                    uiz_updater_FixViews_area_selfmarked(ix+oldselpxmin,iy+(selp1min)*lsz,ilx,iy+(selp1min+1)*lsz)
                    }else{
                    //coming from bottom
                    uiz_updater_FixViews_area_selfmarked(ix+min(oldselpxmin,selpxmin),iy+(selp1min)*lsz,ilx,iy+(selp1min+1)*lsz)
                    }
                    if selp2max-selp1min&gt;1 then{//a middle line exists
                    uiz_updater_FixViews_area_selfmarked(ix,iy+(selp1min+1)*lsz,ilx,iy+(selp2max)*(lsz))
                    }
                    //last line
                    //uiz_updater_FixViews_area_selfmarked(ix,iy+(selpmaxline)*lsz,ix+selpx2,iy+(selpmaxline+1)*lsz)
                    if oldselpsign=1 then{
                    //coming from bottom
                    uiz_updater_FixViews_area_selfmarked(ix,iy+(selp2max)*lsz,ix+oldselpxmax,iy+(selp2max+1)*lsz)
                    }else{
                    //coming from top
                    uiz_updater_FixViews_area_selfmarked(ix,iy+(selp2max)*lsz,ix+max(selpxmax,oldselpxmax),iy+(selp2max+1)*lsz)
                    }
                }else{
                uiz_updater_FixViews_area_selfmarked(ix+min(oldselpxmin,selpxmin),iy+(selpminline)*lsz,ix+max(oldselpxmax,selpxmax),iy+((selpmaxline)+1)*(lsz))
                //uiz_updater_FixViews_area_selfmarked(ix+min(oldselpxmin,selpxmin),iy+min(selpminline,oldselpminline)*lsz,ix+max(oldselpxmax,selpxmax),iy+(max(selpmaxline,oldselpmaxline)+1)*(lsz))
                }
            } else {
                //p2 is first
                selpminline = selp2line
                selpmaxline = selp1line
                selpmin = selp2;
                selpmax = selp1;
                qstr_selpmin = qstr_selp2;
                qstr_selpmax = qstr_selp1;
                selpxmin = selpx2;
                selpxmax = selpx1;
                fixSelLines=true;
                
                
                //first line
                var selp1min = min(oldselpminline,selpminline);
                uiz_updater_FixViews_area_selfmarked(ix+min(oldselpxmin,selpxmin),iy+(selp1min)*lsz,ilx,iy+(selpminline+1)*lsz)
                if selpmaxline-selp1min&gt;1 then{//a middle line exists
                uiz_updater_FixViews_area_selfmarked(ix,iy+(selp1min+1)*lsz,ilx,iy+(selpmaxline)*(lsz))
                }
                //last line
                //uiz_updater_FixViews_area_selfmarked(ix,iy+(selpmaxline)*lsz,ix+selpx2,iy+(selpmaxline+1)*lsz)
                uiz_updater_FixViews_area_selfmarked(ix,iy+(selpmaxline)*lsz,ix+selpxmax,iy+(selpmaxline+1)*lsz)
                
            }
                
        }
        //END setting min and max variables

        if hasselection &amp;&amp; (selpminline!=oldselpminline || selpmaxline!=oldselpmaxline) then{
//                    debugText="lastdiff: "+string(lastselpdiff)+" | " +string(irandom(10000));
                    if lastselpdiff=0 then{
                        //debugText="Doing diff"+string(irandom(10000));
                        uiz_updater_FixViews_area_selfmarked(ix+oldselpxmin,iy+(oldselpminline)*lsz,ix+oldselpxmax,iy+(oldselpminline+1)*lsz)
    }
    }
        
        //fix selection lines to draw:
        if fixSelLines=true then{
        selpline=string_copy(value,selpmin+1,selpmax)
                //find next newline
                var selplineFull = string_copy(qstr,qstr_selpmin+2,qstr_selpmax-qstr_selpmin)
                var lines = uiz_stringUntilNewline(selplineFull);
                selplineBeg=lines[0];
                selplineMidEnd=lines[1];
                linepos = "";
        }
        qstr_leftovers = string_copy(qstr,qstr_selpmax+2,string_length(qstr)-qstr_selpmax);
        var qstr_lines = uiz_stringUntilNewline(qstr_leftovers);
        qstr_lineBeg = qstr_lines[0];
        qstr_lineMidEnd = qstr_lines[1];
        
        
    }
    /*
    if hasmouse=false then{
        if selpmin==selpmax then{
            hasselection=0
        }
    }
    */
    //*/
    if kmouseover = 4 and uiz_getmouse_x() &lt; slx - scblwidth and scroll &lt; 0 then {
        pos = vpos - minpos
        //uiz_textare_snappos_left()
        //sdbm("setpos",vpos-minpos,vpos,minpos,pos)
        //qpos=qstrpos
        //reH
    }
}
if hasselection = 0 and pos &gt; 0 then {
        typing = true;
        uiz_updater_step();
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///temp debug fixing of views
if keyboard_check(vk_f12) then{
uiz_updater_FixViews();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///handle correct mouse cursor
if kmouseover&gt;0 then{uiz_set_cursor(cr_beam)}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_mouse_docheck()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//update=0;
//updated=0
//draw_debugpoint(slx-scblwidth,10,c_green)
if uiz_cntn() then{

//draw background
//draw_square(rx,ry,rlx,rly,c_white,alpha)
uiz_back()
//setup text settings

draw_set_valign(fa_top)
draw_set_halign(fa_left)

//draw the selection background
var lns=selpmaxline-selpminline
var scr_width_en = scblwidth*doscroll;
if lns&gt;0 || forceMultilineDraw then{
//all of the colors were selectbackcolor
if lns&gt;0 then{
//first line
draw_square(ix+selpxmin,iy+selpminline*lsz,ilx-scr_width_en,iy+(selpminline+1)*(lsz),c_green,alpha)
//last line
draw_square(ix,iy+selpmaxline*lsz,ix+selpxmax,iy+(selpmaxline+1)*(lsz),c_purple,alpha)
if lns&gt;1 then{
//middle lines
draw_square(ix,iy+(selpminline+1)*(lsz),ilx-scr_width_en,iy+selpmaxline*lsz,c_fuchsia,alpha)
}
}else{
draw_square(ix+selpxmin,iy+selpminline*lsz,ix+selpxmax,iy+(selpminline+1)*(lsz),c_maroon,alpha)
        draw_set_color(selecttextcolor)
        //draw_text(ix,iy,qstr)
        draw_text(ix+selpxmin,iy+(selpmaxline)*lsz,selpline);
}

//draw text
    draw_set_color(textcolor)
    //draw_text(rx,ry,qstr)
    draw_text(ix,iy,string_copy(qstr,1,qstr_selp1+1))
    //draw_text(ix+selpxmax,iy+selpmaxline*lsz,string_copy(qstr,selpmax-lastbegscrpos,string_length(qstr)-(selpmax-lastbegscrpos)))
    draw_text(ix+selpxmax,iy+selpmaxline*lsz,qstr_lineBeg);
    draw_text(ix,iy+(selpmaxline+1)*lsz,qstr_lineMidEnd);
    
    draw_set_color(selecttextcolor)
    //draw_text(ix+selpxmin,iy+selpminline*lsz,uiz_textarea_getselection(id))
    draw_text(ix+selpxmin,iy+selpminline*lsz,selplineBeg)
    draw_text(ix,iy+(selpminline+1)*lsz,selplineMidEnd)

forceMultilineDraw=false;
}else{
//if lns&lt;=0{
if selpxmin!=selpxmax then{
if uiz_selfmarked=true then{
//sdbm("Executing here",irandom(100));
//first line
        draw_square(ix+selpxmin,iy+selpminline*lsz,ix+selpxmax,iy+(selpminline+1)*(lsz),c_red,alpha)
        draw_set_color(textcolor)
        draw_set_halign(fa_right)
        draw_text(ix+selpxmin,iy+selpmaxline*lsz,selplineBeg);
        draw_set_halign(fa_left)
        draw_text(ix+selpxmax,iy+selpmaxline*lsz,selplineMidEnd);
        
        draw_set_color(selecttextcolor)
        //draw_text(ix,iy,qstr)
        draw_text(ix+selpxmin,iy+(selpmaxline)*lsz,selpline);
    }else{
        draw_set_color(textcolor)
        draw_text(ix,iy,qstr)
        draw_square(ix+selpxmin,iy+selpminline*lsz,ix+selpxmax,iy+(selpminline+1)*(lsz),c_red,alpha)
        draw_set_color(selecttextcolor)
        draw_text(ix+selpxmin,iy+(selpmaxline)*lsz,selpline);
    }
    
}else{
//draw text
    draw_set_color(textcolor)
if uiz_selfmarked=true then{
    draw_text(ix+oldposx,iy+(posline)*lsz,qstr_lineBeg)
    draw_text(ix,iy+(posline+1)*lsz,qstr_lineMidEnd)
}else{


    draw_text(ix,iy,qstr)
    }
    }
}
/*
if pos&gt;0 and hasselection=false and posline&gt;=0 and posline*lsz&lt;height then{
count+=1/(countspeed*room_speed);
if count&gt;=1 then{count=0}
if count&lt;0.5 then{
var anim=uiz_animation_getFunction(count*2,typeanimationin)
}else{
var anim=1-uiz_animation_getFunction((count-0.5)*2,typeanimationout)}
draw_set_alpha(anim*alpha)
draw_set_color(typecolor)
draw_line(ix+posx,iy+(posline)*lsz,ix+posx,iy+(posline+1)*lsz)
}else{
//sdbm("textareadebug",pos,hasselection,posline,posline*lsz,height)
}
*/
//draw_set_alpha(1)
//draw scrollbar
if doscroll=true then{
scroll=uiz_drawscrollbar_vertical_legacy(ilx-scblwidth,iy,ilx,ily,scrollbarsprite,scrollbarcolor,scrollbartexturemode,scroll,scrolllines,true,scrollspeed)
}else{scroll=-1;}

uiz_containend()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_endobject()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_endobject()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var extraLineWidth = 0;
var qstrsz = string_length(qstr);
for(var i=qstrpos;i&lt;=qstrsz;i++){
var c = string_char_at(qstr,i);
if c='#' or c=chr($0A) then{
    break;
}
extraLineWidth+=string_width(c);
}


//draw_square(100,100,500,1000,c_gray,0.7);
draw_set_alpha(1);
//draw_set_color(c_green)
//draw_rectangle(ix+posx,iy,ix+posx+extraLineWidth+10,iy+10,false)
draw_set_color(c_black)


var h=100;

draw_text(100,h,"keyboard_key: "+string(keyboard_key))
h+=string_height(keyboard_key)+10;

draw_text(100,h,"keyboard_string: "+string(keyboard_string))
h+=string_height(keyboard_string)+10;

draw_text(100,h,"hasselection: "+string(hasselection))
h+=string_height(hasselection)+10;

draw_text(100,h,"typing: "+string(typing))
h+=string_height(typing)+10;

draw_text(100,h,"anim: "+string(count))
h+=string_height(count)+10;

draw_text(100,h,"posx: "+string(posx))
h+=string_height(posx)+10;

draw_text(100,h,"posline: "+string(posline))
h+=string_height(posline)+10;

draw_text(100,h,"lsz: "+string(lsz))
h+=string_height(lsz)+10;

draw_text(100,h,"pos: "+string(pos))
h+=string_height(pos)+10;
draw_text(100,h,"vpos: "+string(vpos))
h+=string_height(vpos)+10;

draw_text(100,h,"qstrpos: "+string(qstrpos))
h+=string_height(qstrpos)+10;


draw_text(100,h,"debug: "+string(debugText))
h+=string_height(debugText)+10;


draw_text(100,h,"selpmaxline: "+string(selpmaxline))
h+=string_height(selpmaxline)+10;
draw_text(100,h,"selpminline: "+string(selpminline))
h+=string_height(selpminline)+10;


vastr = uiz_addchar(value,pos-1,'&lt;--&gt;');
draw_text(100,h,"value: "+string(vastr))
h+=string_height(vastr)+10;
draw_text(100,h,"selpline: "+string(selpline))
h+=string_height(selpline)+10;
draw_text(100,h,"selplineBeg: "+string(selplineBeg))
h+=string_height(selplineBeg)+10;
draw_text(100,h,"selplinemidEnd: "+string(selplineMidEnd))

h+=string_height(selpmin)+10;
draw_text(100,h,"selpmin: "+string(selp1))

h+=string_height(selpmax)+10;
draw_text(100,h,"selpmax: "+string(selp2))

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
