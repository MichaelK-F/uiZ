<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///#define uiZ
//#sprite images
//#spritenum 24
//#objectversion 1.0
uiz_objinit()
font=-1//f//font//
textcolor=c_black//c//text color//
selecttextcolor=c_white//c//selection text color//
selectbackcolor=12820740//c//selection background color//

scrollbarsize=0.2//v//scrollbarsize//
scrollbarsizetype=dp//z//scrollbarsizetype//
scrollbarsprite=spr_uiZ_scrollbar//p//sprite//
scrollbarcolor=c_white//c//color//
scrollbartexturemode=uiz_texturemode_fill_edgeless//t//texturemode//
scrollspeed=0.5//v//scrollspeed in dp//
scrollbarAnimation=uiz_smoothstep//a//scrollbar animation//
scrollbarAnimationTime=0.2//v//scrollbar animation time//


accountspeed=.5//v//rapid mode count time//
accbetween=.02//v//rapid mode speed//

typeanimationin=uiz_exponential_in//a//type animation in//
typeanimationout=uiz_exponential_in//a//type animation out//
typeAnimationTime=1//v//type animation time//
typecolor=c_black//c//type indicater color//
cursorwidth=3//c//type indicater thickness//

//clippedLineEnableFactor=0.5;//v//clipped line factor//

hasbackground=true;
texturescript=uiz_back_circlestitch//i//texturescript//
texturescript_over=-1//i//texturescript over//
texturescript_in=-1//i//texturescript in//
texturescript_out=-1//i//texturescript out//

sprite_normal=spr_uiZ_border1//p//sprite normal//
color_normal=c_white//c//color normal//
margin_normal=5//v//margin normal//
sprite_texturemode=uiz_texturemode_fill//t//texturemode normal
border_texturemode=-1//t//texturemode border//

sprite_over=spr_uiZ_border1_over//p//sprite over//
color_over=-1//c//color over//
margin_over=-1//v//margin over//

sprite_in=spr_uiZ_border1_in//p//sprite in//
color_in=-1//c//color in//
margin_in=-1//v//margin in//

sprite_out=spr_uiZ_border1_in//p//sprite out//
color_out=-1//c//color out//
margin_out=-1//v//margin out//
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>textList = ds_list_create();
fontHeight=string_height("{|}");

doscroll=false;
scroll=uiz_drawscrollbar_init();
scrolllines=0;
scblwidth=0;
listFromPx=0;


//isTyping and hasSelection should never be true at the same time. If that's the case it should be considered a bug.
isTyping=false;
hasSelection=false;

//hasMousePressed=false;
redoSelection=false;

selection1Line=-1;
selection1X=-1;
selection1Char=-1;

selection2Line=-1;
selection2X=-1;
selection2Char=-1;

selectionMinLine=selection1Line;
selectionMinX=selection1X;
selectionMinChar=selection1Char;

selectionMaxLine=selection2Line;
selectionMaxX=selection2X;
selectionMaxChar=selection2Char;

last_selectionMinLine=selectionMinLine;
last_selectionMinChar=selectionMinChar;

last_selectionMaxLine=selectionMaxLine;
last_selectionMaxChar=selectionMaxChar;

last_moveVerticalX = -1;

lastReworkAvWidth = -1;

last_isScrollbarSelected = false;

addToNextLineCheck_sel1 = true;
addToNextLineCheck_sel2 = true;

typeanimcount=0;
account=0;

whatsign="";
changesign = false;
lastkeyboard_key = keyboard_key;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_textarea_end();
uiz_endobject()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if doscroll=true then{
    uiz_drawscrollbar_vertical_step(ilx-scblwidth,iy,ilx,ily,scroll,scrolllines,true,uiz_getposx(scrollspeed,dp),scrollbarAnimation, scrollbarAnimationTime);
    uiz_textarea_updateScrollPx();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//check if step event is still valid
if (global.mouseover != id &amp;&amp; mouse_check_button(mb_left)
    //&amp;&amp; !(instance_exists(global.mouseover) &amp;&amp; (global.mouseover.object_index=obj_uiZ_window &amp;&amp; (global.mouseover.isresizing || global.mouseover.isresizing)))
) || (isTyping == false &amp;&amp; hasSelection == false) {
    uiz_updater_unstep();
    uiz_typecursor_deregister();
    isTyping = false;
    exit;
}

if hasSelection = true then {
    isTyping = false;
    uiz_typecursor_deregister();
}

if isTyping then {
    //handle typing animation
    typeanimcount = uiz_animation_increaseCounter(typeanimcount, typeAnimationTime)
    uiz_typecursor_setalpha(uiz_animation_getFunction_twoWay(typeanimcount, uiz_exponential_in, uiz_exponential_in))
}


if font &gt; -1 then {
    draw_set_font(font);
} //font style needed by some function
if keyboard_check(keyboard_key) and!(keyboard_key = 0) then {
    //account = min(account + (1 / (accountspeed * room_speed)), 1)
    account = min(account + uiz_sc(accountspeed), 1)
} else {
    account = 0
}
if lastkeyboard_key != keyboard_key then {
    account = 0
}
if (keyboard_check_pressed(keyboard_key) or account = 1) and!(keyboard_key = 0) then {
if ds_list_size(textList)==0 then{
    textList[| 0]="";
}
    //handle typing
    var canProceedNormalKeyHandling = true;
    if keyboard_check(vk_control) then {
        switch (keyboard_key) {
            case ord('C'): //copy
                if hasSelection then {
                    clipboard_set_text(uiz_textarea_getselection(id));
                }
                canProceedNormalKeyHandling = false;
                break;
            case ord('X'): //cut
                if hasSelection then {
                    clipboard_set_text(uiz_textarea_getselection(id));
                    uiz_textarea_deleteSelection();
                    uiz_textarea_updateTextPart(selection1Line);
                }
                canProceedNormalKeyHandling = false;
                break;
            case ord('V'): //paste
                if hasSelection then{
                    uiz_textarea_deleteSelection();
                }
                uiz_textarea_addstring(clipboard_get_text());
                canProceedNormalKeyHandling = false;
            break;
            case ord('A'): //copy
                uiz_textarea_selectAll();
                canProceedNormalKeyHandling = false;
            break;
        }

    }

    if canProceedNormalKeyHandling then { //control isn't pressed

        //do typing
        account = account - (accbetween/accountspeed)
        var canProceedNormalKeyHandling = true;
        if hasSelection then {
            switch (keyboard_key) {
                case vk_home:
                case vk_end:
                    if !keyboard_check(vk_shift) then{
                    uiz_textarea_FixView_selection(false);
                    uiz_textarea_selectionToSecondCursor();
                    }
                    canProceedNormalKeyHandling = true;
                    break;
                case vk_backspace:
                case vk_delete:
                    uiz_textarea_deleteSelection();
                    uiz_textarea_updateTextPart(selection1Line);
                    canProceedNormalKeyHandling = false;
                    break;
                case vk_enter:
                    uiz_textarea_deleteSelection();
                    uiz_textarea_updateTextPart(selection1Line);
                    canProceedNormalKeyHandling = true;
                    break;
                case vk_left:
                    if !keyboard_check(vk_shift) then {
                        uiz_textarea_FixView_selection(false);
                        uiz_textarea_selectionToLeftCursor();
                        canProceedNormalKeyHandling = false;
                    }
                    break;
                case vk_right:
                    if !keyboard_check(vk_shift) then {
                        uiz_textarea_FixView_selection(false);
                        uiz_textarea_selectionToRightCursor();
                        canProceedNormalKeyHandling = false;
                    }
                    break;
                case vk_up:
                    if !keyboard_check(vk_shift) then {
                        uiz_textarea_FixView_selection(false);
                        uiz_textarea_selectionToFirstCursor();
                        canProceedNormalKeyHandling = false;
                    }
                    break;
                case vk_down:
                    if !keyboard_check(vk_shift) then {
                        uiz_textarea_FixView_selection(false);
                        uiz_textarea_selectionToSecondCursor();
                        canProceedNormalKeyHandling = false;
                    }
                    break;
                default:
                    //remove selection and continue
                    if uiz_textarea_checkKeyboardTypingValidity() then {
                        uiz_textarea_FixView_selection(true);
                        //remove selection
                        uiz_textarea_deleteSelection();
                        canProceedNormalKeyHandling = true;
                    }
                    break;
            }
        }
        uiz_textarea_testCursorNewLine();
        if canProceedNormalKeyHandling then {
            switch (keyboard_key) {
                case vk_home:
                    if keyboard_check(vk_shift) then {
                        if keyboard_check(vk_control) then{//move to begin of first line
                        uiz_textarea_moveSelectionHomeLine();
                    }else{//move to begin of this line
                        uiz_textarea_moveSelectionHome();
                        }
                    } else {
                    if keyboard_check(vk_control) then{//move to begin of first line
                        uiz_textarea_moveCursorHomeLine();
                    }else{//move to begin of this line
                        uiz_textarea_moveCursorHome();
                        }
                    }
                    break;
                case vk_end:
                if keyboard_check(vk_shift) then {
                if keyboard_check(vk_control) then{//move to end of last line
                    uiz_textarea_moveSelectionEndLine();
                }else{//move to end of this line
                uiz_textarea_moveSelectionEnd();
                }
                }else{
                if keyboard_check(vk_control) then{//move to end of last line
                uiz_textarea_moveCursorEndLine();
                }else{//move to end of this line
                    uiz_textarea_moveCursorEnd();
                    }
                    }
                    break;
                case vk_left:
                    if keyboard_check(vk_shift) then {
                        uiz_textarea_moveSelectionLeft();
                    }else{
                        uiz_textarea_moveCursorLeft();
                    }
                    break;
                case vk_right:
                if keyboard_check(vk_shift) then {
                uiz_textarea_moveSelectionRight();
                }else{
                    uiz_textarea_moveCursorRight();
                    }
                    break;
                case vk_down:
                    if keyboard_check(vk_shift) then {
                    uiz_textarea_moveSelectionDown();
                    }else{
                    uiz_textarea_moveCursorDown();
                    }
                    break;
                case vk_up:
                    if keyboard_check(vk_shift) then {
                    uiz_textarea_moveSelectionUp();
                    }else{
                    uiz_textarea_moveCursorUp();
                    }
                    break;
                case vk_backspace:
                    uiz_textarea_doBackspace(0);
                    break;
                case vk_delete:
                    uiz_textarea_doBackspace(1);
                    break;
                case vk_enter:
                    uiz_textarea_insertNewline();
                    break;
                default:

                    //                if keyboard_check(vk_control) or keyboard_check(vk_alt) or(keyboard_key &gt;= 112 and keyboard_key &lt;= 123) or keyboard_key = 174 or keyboard_key = 175 then {} else {
                    if uiz_textarea_checkKeyboardTypingValidity() then {
                        if changesign then {
                            uiz_textarea_addchar(uiz_returncharaddon(string_char_at(keyboard_string, string_length(keyboard_string)), whatsign))
                        } else {
                            uiz_textarea_addchar(string_char_at(keyboard_string, string_length(keyboard_string)))
                        }
                        whatsign = ""
                        changesign = false;
                        //}

                        break;
                        break;
                    }
            }
        }
        uiz_textarea_testCursorNewLine();
        if !keyboard_check(vk_up) &amp;&amp; !keyboard_check(vk_down) then{//if we aren't moving up or down we can reset our up/down moving X position.
            last_moveVerticalX = -1;
        }

    }
}
lastkeyboard_key = keyboard_key
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///handle selections
//get current mouse position

if doscroll=true then{
var scrbx = ilx-scblwidth;
}else{
var scrbx = ilx;
}
var isScrollbarSelected = uiz_drawscrollbar_getselected(scroll);
//kmouseover=uiz_mouse_isOver_object_leftCheck(id);
//sdbm("cheking...",kmouseover,doscroll,uiz_getmouse_x(),scrbx, isScrollbarSelected, last_isScrollbarSelected)
if kmouseover&gt;=uiz_mouseclick &amp;&amp; (doscroll=false or (uiz_getmouse_x()&lt;scrbx &amp;&amp; !isScrollbarSelected &amp;&amp; !last_isScrollbarSelected)) then{

    uiz_mouse_freeze();
    var selectionCLine=-1;
    var selectionCX=-1;
    var selectionCChar=-1;
    last_moveVerticalX = -1;
    
    
    var lsz = ds_list_size(textList);
    //if lsz=0 then{
    //            exit;
    //}
    selectionCLine=floor((uiz_getmouse_y()-iy+listFromPx)/fontHeight);
    if selectionCLine &gt;=lsz then{
        if lsz==0 then{
            textList[| 0] = "";
            selectionCLine=0;
            selectionCChar = 0;
            selectionCX = ix;
        }else{
            selectionCLine=lsz-1;
            selectionCChar = string_length(textList[| selectionCLine]);
            selectionCX = min(ilx,ix+string_width(textList[| selectionCLine]));
        }
    }else{
        if selectionCLine&lt;0 then{
            selectionCLine=0;
            selectionCChar=0;
            selectionCX=ix;
            //selectionCChar = string_length(textList[| 0]);
            //selectionCX = string_width(textList[| 0])
        }else{
            var testLine = textList[| selectionCLine];
            var testLineSz = string_length(testLine);
            var curX=ix;
            selectionCX=curX;
            var mouseX = uiz_getmouse_x();
            
            for(var i=1;i&lt;=testLineSz;i++){
                var w = string_width(string_char_at(testLine,i));
                if curX+w/2&gt;mouseX then{//when this mouse is further selected beyond this character
                    selectionCChar=i-1;
                    selectionCX=curX;
                    break;
                }
                curX+=w;
            }
            
            if (i&gt;testLineSz){//loop was looped fully, so no selection position was found, just assume the last character then.
                selectionCChar=testLineSz;
                selectionCX=curX;
            }
            }
    }
    
    //put cursor before newline position
    //sdbm("Checking char",textList[| selectionCLine],string_length(textList[| selectionCLine]),string_char_at(textList[| selectionCLine],selectionCChar),ord(string_char_at(textList[| selectionCLine],selectionCChar)))
    if(selectionCChar&gt;0 and string_char_at(textList[| selectionCLine],selectionCChar)==chr($0A)){
        //sdbm("Moving char back")
        --selectionCChar
    }
    
    //handle the newly gotten selection point
    var hadSelection = hasSelection;
    if mouse_check_button_pressed(mb_left) &amp;&amp; (!keyboard_check(vk_shift) || selection1Line==-1) then{
        //hasMousePressed=true;
        selection1Line=selectionCLine;
        selection1X=selectionCX;
        selection1Char=selectionCChar;
    }
    selection2Line=selectionCLine;
    selection2X=selectionCX;
    selection2Char=selectionCChar;
    
    if selection1Line!=-1 then{
        uiz_textarea_testCursorNewLine();
        uiz_textarea_handleSelectingOrTyping();
        uiz_textarea_calculateNewView(hadSelection);
    }
    
    if !mouse_check_button(mb_left) then{
        uiz_mouse_unFreeze();
        //hasMousePressed=false;
    }
    
    
        
    
}else{
    if !mouse_check_button(mb_left) then{
            uiz_mouse_unFreeze();
            //hasMousePressed=false;
        }
}
last_isScrollbarSelected=isScrollbarSelected;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if kmouseover=0 then{
    uiz_drawscrollbar_deselect(ilx-scblwidth,iy,ilx,ily,uiz_vertical,scroll);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if doscroll then{
uiz_mouse_docheck_scrollable()
}else{
uiz_mouse_docheck()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//sdbm("drawing textarea",rx,ry,rlx,rly,irandom(10))
//draw_set_color(c_red);
//draw_rectangle(rx-100,ry-100,rlx+100,rly+100,0);
//draw_set_color(c_white);
if uiz_cntn() then{
//draw background
uiz_back()

//setup text settings
draw_set_valign(fa_top)
draw_set_halign(fa_left)

//set style
if font&gt;-1 then{draw_set_font(font);}
draw_set_color(textcolor);


//get what lines should be drawn
var listLen = ds_list_size(textList);

var listFrom = uiz_textarea_getListFrom();
var listTo = uiz_textarea_getListTo(listFrom);

if redoSelection=true and hasSelection=true then{
    var listFrom = max(min(last_selectionMinLine,selectionMinLine),listFrom);
    var listTo = min(max(last_selectionMaxLine,selectionMaxLine),listTo);
}

var listFromFloor = floor(listFrom);
var listFromCeil = ceil(listFrom);
var listToFloor = floor(listTo);
var listToCeil = ceil(listTo);

redoSelection=false;

if doscroll=true then{
var scrbx = ilx-scblwidth-1;
}else{
var scrbx = ilx;
}

//draw scrollbar
if doscroll=true then{
uiz_drawscrollbar_vertical_draw(ceil(scrbx+1),iy,ilx,ily,scrollbarsprite,scrollbarcolor,scrollbartexturemode,scroll,scrolllines)
}

if uiz_selfmarked==false then{
    uiz_contain_custom(ix,iy,scrbx,ily);
}

//draw selection background on full lines
var begSelMainBodyY=iy+max(0,fontHeight*(selectionMinLine+1)-listFromPx)
if(selectionMaxLine-selectionMinLine&gt;1 &amp;&amp; begSelMainBodyY&lt;ily &amp;&amp; hasSelection){
    //draw_square(selectionMinX,iy,selectionMaxX,lineY+fontHeight,selectbackcolor,1);
    draw_square(ix,begSelMainBodyY,scrbx,min(ily,iy+fontHeight*(selectionMaxLine)-listFromPx),selectbackcolor,1);
    //draw_square(ix,iy+(fontHeight+1)*(selectionMaxLine)-listFromPx,selectionMaxX,ily,selectbackcolor,1);
}

//sdbm("listcolorsel: ",listFromCeil,selectionMinLine,listToFloor,selectionMaxLine)
//set color for lines
//if selectionMinLine&gt;=0 &amp;&amp; selectionMinLine&lt;listFromFloor  then{
//if selectionMinLine&gt;=0 &amp;&amp; selectionMinLine&lt;=listFrom-clippedLineEnableFactor &amp;&amp; selectionMaxLine&gt;=listFrom-clippedLineEnableFactor then{// &amp;&amp; selectionMaxLine&gt;listFromFloor then{
if hasSelection &amp;&amp; selectionMinLine&gt;=0 &amp;&amp; selectionMinLine&lt;listFromFloor &amp;&amp; selectionMaxLine&gt;=listFromFloor then{
    draw_set_color(selecttextcolor);
}else{
    draw_set_color(textcolor);
}
//acutally draw the lines

/*
//draw first (clipped) line
if listFromFloor!=listFrom &amp;&amp; (listFrom-listFromFloor&lt;clippedLineEnableFactor) then{
 if hasSelection then{
    var lineY = iy+fontHeight*listFromFloor-listFromPx;
    if listFromFloor=selectionMinLine &amp;&amp; listFromFloor=selectionMaxLine then{
        uiz_textarea_drawText(ix,iy,string_copy(textList[| listFromFloor],1,selectionMinChar));
        uiz_textarea_drawText(selectionMaxX,iy,string_copy(textList[| listFromFloor],selectionMaxChar+1,string_length(textList[|listFromFloor]))); 
        draw_square(selectionMinX,iy,selectionMaxX,lineY+fontHeight,selectbackcolor,1);
        draw_set_color(selecttextcolor);
        uiz_textarea_drawText(selectionMinX,iy,string_copy(textList[| listFromFloor],selectionMinChar+1,selectionMaxChar-selectionMinChar)); 
        draw_set_color(textcolor);
    }else if listFromFloor=selectionMinLine then{
        uiz_textarea_drawText(ix,iy,string_copy(textList[| listFromFloor],1,selectionMinChar));
        draw_square(selectionMinX,iy,scrbx,lineY+fontHeight,selectbackcolor,1);
        draw_set_color(selecttextcolor);
        uiz_textarea_drawText(selectionMinX,iy,string_copy(textList[| listFromFloor],selectionMinChar+1,string_length(textList[| listFromFloor])-selectionMinChar)); 
    }else if listFromFloor=selectionMaxLine then{
        draw_square(ix,iy,selectionMaxX,lerp(iy,lineY,1-(listFrom-listFromFloor)*2)+fontHeight,selectbackcolor,1);
        draw_set_color(selecttextcolor);
        uiz_textarea_drawText(ix,iy,string_copy(textList[| listFromFloor],1,selectionMaxChar)); 
        draw_set_color(textcolor);
        //draw surrounding selection
        uiz_textarea_drawText(selectionMaxX,iy,string_copy(textList[| listFromFloor],selectionMaxChar+1,string_length(textList[|listFromFloor]))); 
    }
    }else{
        uiz_textarea_drawText(ix,iy,textList[| listFromFloor]);
    }
     
}
*/


//if selectionMinLine&gt;=0 &amp;&amp; selectionMaxLine&gt;=0 &amp;&amp; listFromCeil&lt;=selectionMaxLine &amp;&amp; listToFloor&gt;=selectionMinLine then{
//text begins with selected text
//draw_set_color(selecttextcolor);
//}


//draw main lines
//for(var i=listFromCeil;i&lt;listToFloor;i++){
for(var i=listFromFloor;i&lt;listToCeil;i++){
    var lineY = iy+fontHeight*i-listFromPx;
    if i&gt;=selectionMinLine &amp;&amp; i&lt;=selectionMaxLine &amp;&amp; hasSelection then{
        if i=selectionMinLine &amp;&amp; i=selectionMaxLine then{
            //draw surrounding selection
            uiz_textarea_drawText(ix,lineY,string_copy(textList[| i],1,selectionMinChar));
            uiz_textarea_drawText(selectionMaxX,lineY,string_copy(textList[| i],selectionMaxChar+1,string_length(textList[|i]))); 
            //draw selecion itself
            draw_square(selectionMinX,lineY,selectionMaxX,lineY+fontHeight,selectbackcolor,1);
            draw_set_color(selecttextcolor);
            uiz_textarea_drawText(selectionMinX,lineY,string_copy(textList[| i],selectionMinChar+1,selectionMaxChar-selectionMinChar)); 
            draw_set_color(textcolor);
            continue;
        }
        
        if i=selectionMinLine then{
            //draw surrounding selection
            uiz_textarea_drawText(ix,lineY,string_copy(textList[| i],1,selectionMinChar));
            //draw selection itself
            draw_square(selectionMinX,lineY,scrbx,lineY+fontHeight,selectbackcolor,1);
            draw_set_color(selecttextcolor);
            uiz_textarea_drawText(selectionMinX,lineY,string_copy(textList[| i],selectionMinChar+1,string_length(textList[| i])-selectionMinChar)); 
            continue;
        }
        
        if i=selectionMaxLine then{
            //draw selection itself
            draw_square(ix,lineY,selectionMaxX,lineY+fontHeight,selectbackcolor,1);
            draw_set_color(selecttextcolor);
            uiz_textarea_drawText(ix,lineY,string_copy(textList[| i],1,selectionMaxChar)); 
            draw_set_color(textcolor);
            //draw surrounding selection
            uiz_textarea_drawText(selectionMaxX,lineY,string_copy(textList[| i],selectionMaxChar+1,string_length(textList[|i])-selectionMaxChar)); 
            continue;
        }
           //we came here so we have fully selected line, just draw the text outside this if. 
        }
        
    
    uiz_textarea_drawText(ix,lineY,textList[| i]); 

       
    
}

//draw last (clipped) line
/*
if listTo!=listToFloor &amp;&amp; (listTo-listToFloor&gt;clippedLineEnableFactor) then{
    draw_set_valign(fa_bottom);
    if (listToFloor==selectionMaxLine || listToFloor==selectionMinLine) &amp;&amp; hasSelection then{
        var lineY = iy+fontHeight*listToFloor-listFromPx;
        if listToFloor=selectionMaxLine then{
            if (hasSelection){
                draw_square(ix,min(ily,max(ily-fontHeight,iy+fontHeight*(selectionMaxLine)-listFromPx)),selectionMaxX,ily,selectbackcolor,1);
                draw_set_color(selecttextcolor);
            }
            uiz_textarea_drawText(ix,ily,string_copy(textList[| listToFloor],1,selectionMaxChar)); 
            draw_set_color(textcolor);
            //draw surrounding selection
            uiz_textarea_drawText(selectionMaxX,ily,string_copy(textList[| listToFloor],selectionMaxChar+1,string_length(textList[|listToFloor])));
        }else{//listToFloor=selectionMinLine
            //draw normal selection
            uiz_textarea_drawText(ix,ily,string_copy(textList[| listToFloor],1,selectionMinChar));  
            if (hasSelection) then{
                //draw selection
                draw_square(selectionMinX,min(ily,lerp(ily-fontHeight,iy+fontHeight*(selectionMinLine)-listFromPx,1-(listFrom-listFromFloor)*2)),scrbx,ily,selectbackcolor,1);
                draw_set_color(selecttextcolor);
            }
            uiz_textarea_drawText(selectionMinX,ily,string_copy(textList[| listToFloor],selectionMinChar+1,string_length(textList[|listToFloor])));
        }
        
    }else{
        uiz_textarea_drawText(ix,ily,textList[| listToFloor]);
    }
    
}
*/

uiz_containend()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_textarea_end();
uiz_endobject()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_textarea_end();
uiz_endobject()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
//draw_square(100,100,500,1000,c_gray,0.7);
draw_set_alpha(1);
//draw_set_color(c_green)
//draw_rectangle(ix+posx,iy,ix+posx+extraLineWidth+10,iy+10,false)
draw_set_color(c_black)


var h=100;

draw_text(100,h,"keyboard_key: "+string(keyboard_key));
h+=string_height("1")+10;
draw_text(100,h,"keyboard_char: "+string(keyboard_lastchar));
h+=string_height("1")+10;
draw_text(100,h,"obj_uiZ_controller.keyboard_charPressed: "+string(obj_uiZ_controller.keyboard_charPressed));
h+=string_height("1")+10;

draw_text(100,h,"hasSelection: "+string(hasSelection));
h+=string_height("1")+10;
draw_text(100,h,"isTyping: "+string(isTyping));
h+=string_height("1")+10;

draw_text(100,h,"list size: "+string(ds_list_size(textList)));
h+=string_height("1")+10;
//draw_text(100,h,"scroll: "+string(scroll));
//h+=string_height("1")+10;

draw_text(100,h,"selection1Line: "+string(selection1Line));
h+=string_height("1")+10;
draw_text(100,h,"selection1X: "+string(selection1X));
h+=string_height("1")+10;
draw_text(100,h,"selection1Char: "+string(selection1Char));
h+=string_height("1")+10;

draw_text(100,h,"selection2Line: "+string(selection2Line));
h+=string_height("1")+10;
draw_text(100,h,"selection2X: "+string(selection2X));
h+=string_height("1")+10;
draw_text(100,h,"selection2Char: "+string(selection2Char));
h+=string_height("1")+10;

draw_text(100,h,"selectionMinLine: "+string(selectionMinLine));
h+=string_height("1")+10;
draw_text(100,h,"selectionMinX: "+string(selectionMinX));
h+=string_height("1")+10;
draw_text(100,h,"selectionMinChar: "+string(selectionMinChar));
h+=string_height("1")+10;

draw_text(100,h,"selectionMaxLine: "+string(selectionMaxLine));
h+=string_height("1")+10;
draw_text(100,h,"selectionMaxX: "+string(selectionMaxX));
h+=string_height("1")+10;
draw_text(100,h,"selectionMaxChar: "+string(selectionMaxChar));
h+=string_height("1")+10;

draw_text(100,h,"lines: "+string(ds_list_size(textList)));
h+=string_height("1")+10;
draw_text(100,h,"selectionMaxX: "+string(string_width(textList[|ds_list_size(textList)-1])));
h+=string_height("1")+10;
draw_text(100,h,"selectionchars: "+string(string_length(textList[|ds_list_size(textList)-1])));
h+=string_height("1")+10;

draw_text(100,h,"hasSelection: "+string(hasSelection));
h+=string_height("1")+10;

draw_text(100,h,"sign(selection2Line-selection1Line): "+string(sign(selection2Line-selection1Line)));
h+=string_height("1")+10;

draw_text(100,h,"clipboard: "+clipboard_get_text());
h+=string_height("1")+10;

//get what lines should be drawn
var listLen = ds_list_size(textList);

if redoSelection=true and hasSelection=true then{
    var listFrom = max(min(last_selectionMinLine,selectionMinLine),listFromPx/fontHeight);
    var listTo = min(max(last_selectionMaxLine,selectionMaxLine),listFrom+iheight/fontHeight);
}else{
    var listFrom = (listFromPx/fontHeight);
    var listTo = min(listLen,listFrom+iheight/fontHeight);
}

var listFromFloor = floor(listFrom);
var listFromCeil = ceil(listFrom);
var listToFloor = floor(listTo);
var listToCeil = ceil(listTo);
draw_text(100,h,"listFrom: "+string(listFrom));
h+=string_height("1")+10;
draw_text(100,h,"listTo: "+string(listTo));
h+=string_height("1")+10;


draw_text(100,h,"mousefrozen: "+string(global.mousefrozen));
h+=string_height("1")+10;
draw_text(100,h,"mouse_button: "+string(mouse_check_button(mb_left)));
h+=string_height("1")+10;
draw_text(100,h,"mouse_pressed: "+string(mouse_check_button_pressed(mb_left)));
h+=string_height("1")+10;
draw_text(100,h,"kmouseover: "+string(kmouseover));
h+=string_height("1")+10;

draw_text(100,h,"global.uiz_stepNumber: "+string(global.uiz_stepNumber));
h+=string_height("1")+10;

/*
draw_set_color(c_red);
draw_line_width(selection1X,iy+selection1Line*fontHeight,selection1X,iy+(selection1Line+1)*fontHeight,1);
draw_set_color(c_green);
draw_line_width(selection2X,iy+selection2Line*fontHeight,selection2X,iy+(selection2Line+1)*fontHeight,1);
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
