<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.lockwindowresel=global.lockwindowreseltime;
lastparent=obj_uiZ_controller.id;
//lastparent=0;
m=0;
u=0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///#define uiZ
//#sprite images
//#spritenum 17
//#objectversion 1.0
//#exclude
//global.count=2
uiz_objinit()
draw=0
mark=1
markcolor=irandom(255*255*255)
//texturemode=uiz_texturemode_tile
//bordertexturemode=uiz_texturemode_fill
//bordercolor=c_white
iscover=0
fromx=0
fromy=0
tox=0
toy=0
topbordermargin=3;
rightbordermargin=3;
bottombordermargin=3;
leftbordermargin=3;
maximizesnapmargin=5//v//snap maximize margin//
//bordersprite=spr_uiZ_windowborder;
//bordersprite=spr_uiZ_border1;
windowtext="window"//s//window text//
//drawwindowtext=""
windowtextcolor=c_black//c//window text color//
barsize=0.25
barsizevaltype=dp
//windowtopcolor=c_aqua
//windowtopalpha=1
//windowmaincolor=c_white
//windowmainalpha=1
button_cross=1
button_maximize=1
button_minimize=1
oldbutton_cross=1
oldbutton_maximize=1
oldbutton_minimize=1

button_cross_color_normal=c_white;
button_cross_color_over=c_white;
button_cross_color_in=c_white;
button_cross_sprite=spr_uiZ_windowbutton_cross;

button_maximize_color_normal=c_white;
button_maximize_color_over=c_white;
button_maximize_color_in=c_white;
button_maximize_sprite=spr_uiZ_windowbutton_maximize;

button_minimize_color_normal=c_white;
button_minimize_color_over=c_white;
button_minimize_color_in=c_white;
button_minimize_sprite=spr_uiZ_windowbutton_minimize;

addwindowdepth=0
mainframe=0
snaptomouse=0
mouseminx=0
mouseminy=0
//windowminx=0
//windowminy=0
sizestatus=1
oldx=x
oldy=y
olda=1
oldwidth=width
oldheight=height
inanimation=0
maximizeanimation=uiz_elastic_inout
maximizeanimationspeed=0.3
unmaximizeanimation=uiz_elastic_inout
unmaximizeanimationspeed=0.2
minimizeanimation=uiz_wigle
minimizeanimationspeed=0.3
unminimizeanimation=uiz_wigle
unminimizeanimationspeed=0.2
destroyyfunction=uiz_straight
destroyxfunction=uiz_straight
destroyafunction=uiz_straight
destroyspeed=0.5
destroy=0
finaldestroy=0
destroycount=0
destroycountspeed=0.1
destroycountanimation=uiz_elastic_inout
contain=uiz_window_contain_corner//v//contain constant//
resizable=true;
halign=fa_left
valign=fa_center
font=-1;
wholewidthalign=false;
keepratio=false;
minwidth=0;
minwidthtype=px;
minheight=0;
minheighttype=px;
ratio=1;
minw=0;
minh=0;
bars=0;
//uiz_window_fixminwh()

graboffx=0;
graboffy=0;

//lastparent=0;


isresizing=false;
doublemargins=false//b//double topbar margins//
topbarInside=false//b//topbar in inner margins//
topbackuse=-1;

hasbackground=true;
texturescript=uiz_back_circlestitch//i//texturescript//
texturescript_over=-1//i//texturescript over//
texturescript_in=-1//i//texturescript in//
texturescript_out=uiz_back_square//i//texturescript out//

sprite_normal=spr_uiZ_border1//p//sprite normal//
color_normal=c_white//c//color normal//
margin_normal=10//v//margin normal//
sprite_texturemode=uiz_texturemode_fill//t//texturemode normal
border_texturemode=-1//t//texturemode border//

sprite_over=spr_uiZ_border1_over//p//sprite over//
color_over=-1//c//color over//
margin_over=-1//v//margin over//

sprite_in=spr_uiZ_border1_in//p//sprite in//
color_in=-1//c//color in//
margin_in=-1//v//margin in//

sprite_out=spr_uiZ_border1_in//p//sprite out//
color_out=-1//c//color out//
margin_out=-1//v//margin out//

usebackgroundmargins=true;



top_texturescript=uiz_back_circlestitch//i//top texturescript//
top_texturescript_over=-1//i//top texturescript over//
top_texturescript_in=-1//i//top texturescript in//
top_texturescript_out=-1//i//top texturescript out//

top_sprite_normal=spr_uiZ_border1//p//top sprite normal//
top_color_normal=c_white//c//top color normal//
top_margin_normal=10//v//top margin normal//
top_sprite_texturemode=uiz_texturemode_fill//t//top texturemode normal
top_border_texturemode=-1//t//top texturemode border//

top_sprite_over=spr_uiZ_border1_over//p//top sprite over//
top_color_over=-1//c//top color over//
top_margin_over=-1//v//top margin over//

top_sprite_in=spr_uiZ_border1_in//p//top sprite in//
top_color_in=-1//c//top color in//
top_margin_in=-1//v//top margin in//

top_sprite_out=spr_uiZ_border1_in//p//top sprite out//
top_color_out=-1//c//top color out//
top_margin_out=-1//v//top margin out//

top_bkspr=top_sprite_normal;
top_bkcol=top_color_normal;
top_bkmar=top_margin_normal;
top_texas=top_texturescript



button_cross_state=0;
button_maximize_state=0;
button_minimize_state=0;
overbut=0;
loverbut=0;
loverbut_mouse=0;

lkmouseover=0;
addwindowmydepth=0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///custom button control
custom_buttons_left_color_normal=ds_list_create();
custom_buttons_left_color_over=ds_list_create();
custom_buttons_left_color_in=ds_list_create();
custom_buttons_left_sprite=ds_list_create();
custom_buttons_left_state=ds_list_create();
custom_buttons_left_script=ds_list_create();

custom_buttons_right_color_normal=ds_list_create();
custom_buttons_right_color_over=ds_list_create();
custom_buttons_right_color_in=ds_list_create();
custom_buttons_right_sprite=ds_list_create();
custom_buttons_right_state=ds_list_create();
custom_buttons_right_script=ds_list_create();

overbut_left = -1;
loverbut_left = -1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>an_old_posinframex=posinframex;
an_old_posinframey=posinframey;
an_old_setpointx=setpointx;
an_old_setpointy=setpointy;
an_old_x=x;
an_old_y=y;
an_old_width=width;
an_old_height=height;

//if global.selectedwindow.depth&gt;-1000000 then{
uiz_window_select(id)
//}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///handle buttons on left side
if live_call() return live_result;
var butId = uiz_getmouse_x()-ix;
var buts = ds_list_size(custom_buttons_left_sprite);
var butSize = bars * buts;
var checkbuttons = false;

if kmouseover &gt; 0 and uiz_getmouse_y()&gt;=iy-bars+doublemargins*topframemargin and uiz_getmouse_y()&lt;=iy-doublemargins*bottomframemargin and uiz_getmouse_x() &gt; ix and uiz_getmouse_x() &lt; ix+butSize and global.mousefrozen = false and isresizing = 0 and snaptomouse = 0 then {
    checkbuttons = true;
    overbut_left = floor((uiz_getmouse_x()-ix)/bars);
}else{
    overbut_left = -1;
}

var upd=false;
if (loverbut_left != overbut_left and((loverbut_left &gt;= 0 and loverbut_left &lt; buts) or(overbut_left &gt;= 0 and overbut_left &lt; buts))) {
    for(var i=0;i&lt;buts;++i){
        custom_buttons_left_state[| i]=0;
    }
    custom_buttons_left_state[| overbut_left]=1;
    upd=true;
    loverbut_left = overbut_left;
}

if !is_undefined(custom_buttons_left_state[| overbut_left]) and custom_buttons_left_state[| overbut_left] &gt; 0 then{
    var ns=mouse_check_button(mb_left) + 1;
    if ns!=custom_buttons_left_state[| overbut_left] then{
    custom_buttons_left_state[| overbut_left] = ns;
    upd=true;
    }
    if mouse_check_button_released(mb_left) then {
        script_execute(custom_buttons_left_script[| overbut_left],id,overbut_left);
    }
}

if upd=true then{
    uiz_updater_FixViews_area(ix,ry,ix+butSize,iy);//REENABLE//
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///check mouse and rescale window
var fix=false;
kmouseover = uiz_mouse_isonwindow_leftcheck(id);
//sdbm("iding",id,object_index,object_get_name(object_index));
//sdbm(global.mousefrozen,"sn",snaptomouse,"rs",resizable,"km",kmouseover)
if global.mousefrozen = false and snaptomouse = 0 and resizable = 1 and kmouseover &gt; 0{// and(uiz_range_duo(uiz_getmouse_x(), rx, ix, ilx, rlx) or uiz_range_duo(uiz_getmouse_y(), ry, iy, ily, rly)) then {
    isresizing = true;
    isresizing_y = uiz_null;
    isresizing_x = uiz_null;
    var cornerMargin = 10;

    if (uiz_getmouse_x() &gt; rlx - cornerMargin and uiz_getmouse_y() &gt; rly - cornerMargin) then {
        //right bottom
        isresizing_y = uiz_bottom;
        isresizing_x = uiz_right;
        uiz_set_cursor(cr_size_nwse);
    } else {
        //check left bottom
        if (uiz_getmouse_x() &lt; rx + cornerMargin and uiz_getmouse_y() &gt; rly - cornerMargin) then {
            //left bottom
            isresizing_y = uiz_bottom;
            isresizing_x = uiz_left;
            uiz_set_cursor(cr_size_nesw);
        } else {
            //check left top
            if (uiz_getmouse_x() &lt; rx + cornerMargin and uiz_getmouse_y() &lt; ry + cornerMargin) then {
                //left top
                isresizing_y = uiz_top;
                isresizing_x = uiz_left;
                uiz_set_cursor(cr_size_nwse);
            } else {
                //check right top
                if (uiz_getmouse_x() &gt; rlx - cornerMargin and uiz_getmouse_y() &lt; ry + cornerMargin) then {
                    //right top
                    isresizing_y = uiz_top;
                    isresizing_x = uiz_right;
                    uiz_set_cursor(cr_size_nesw);
                } else {
                    //check top
                    if (uiz_getmouse_y() &lt; ry + bkmar + doublemargins*topframemargin) then {
                        //top
                        isresizing_y = uiz_top;
                        uiz_set_cursor(cr_size_ns);
                    } else {
                        //check bottom
                        if (uiz_getmouse_y() &gt; ily) then {
                            //bottom
                            isresizing_y = uiz_bottom;
                            uiz_set_cursor(cr_size_ns);
                        } else {
                            //check left
                            if (uiz_getmouse_x() &lt; ix) then {
                                isresizing_x = uiz_left;
                                uiz_set_cursor(cr_size_we);
                            } else {
                                //check right
                                if (uiz_getmouse_x() &gt; ilx) then {
                                    //right
                                    isresizing_x = uiz_right;
                                    uiz_set_cursor(cr_size_we);
                                } else {
                                    uiz_set_cursor(cr_default);
                                    isresizing = false;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
if !mouse_check_button(mb_left) then{
isresizing=false;
isresizing_y = uiz_null;
isresizing_x = uiz_null;
}
if isresizing=true then{
global.mousefrozen = true;
switch(sizestatus){
case 0:
uiz_window_unminimize();
iwidth=width-end_leftframemargin-end_rightframemargin;
iheight=height-end_topframemargin-end_bottomframemargin;
break;
case 1:
uiz_window_an_old();
break;
}
}
uiz_window_getgraboff();
}
if isresizing=true and !mouse_check_button(mb_left) then{
isresizing=false;
isresizing_y = uiz_null;
isresizing_x = uiz_null;
global.mousefrozen = false;
}

if resizable = 1 and isresizing = true then {
    posinframex = uiz_static;
    posinframey = uiz_static;
    fix=true;
    var pxmovedx,pxmovedy;
    var x_min,y_min,x_max,y_max;
    switch(contain){
        case uiz_window_contain_topbar:
            x_min=parent.ix+end_leftframemargin;
            y_min=parent.iy+end_topframemargin;
            x_max=parent.ilx-end_rightframemargin;
            y_max=99999999999999;
            w_max=parent.ilx;
            h_max=99999999999999;
        break;
        case uiz_window_contain_window:
            x_min=parent.ix+end_leftframemargin;
            y_min=parent.iy+end_topframemargin;
            x_max=parent.ilx-end_rightframemargin;
            y_max=parent.ily-end_bottomframemargin;
            w_max=parent.iwidth;
            h_max=parent.iheight;
        break;
        case uiz_window_contain_corner:
            x_min=-9999999999999;
            y_min=parent.iy+end_topframemargin;
            x_max=99999999999999;//round(parent.ilx - (bars + end_rightframemargin));
            y_max=99999999999999;//round(parent.ily - end_topframemargin);
            w_max=99999999999999;
            h_max=99999999999999;
        break;
        default:
            x_min=-9999999999999;
            y_min=-9999999999999;
            x_max=99999999999999;
            y_max=99999999999999;
            w_max=99999999999999;
            h_max=99999999999999;
        break;
    }
    var xat,yat;
        if keepratio = true and isresizing_y!=uiz_null and isresizing_x!=uiz_null then {
        //some math stuff.
        //have an imaginary diagonal line at an angle of tan-1(ratio).
        //then calculate the closes point of the mouse on that line.
        if (isresizing_x-isresizing_y)=0 then{
        var al=-(ix)*ratio+(iy);
        }else{
        var al=-ilx*ratio+iy;
        }
        var ap=(uiz_getmouse_x()+graboffx)/ratio+(uiz_getmouse_y() + graboffy);
        //var ap=(rlx)/ratio+rly;
        //sdbm("ap",ap,ilx-uiz_getmouse_x()-graboffx,graboffx,ilx,uiz_getmouse_x())
        xat=clamp(round((-al+ap)*ratio/(1+ratio*ratio)),x_min,x_max);
        yat=round(al+xat*ratio);
        var yat_clamp=clamp(yat,y_min,y_max);
        if yat!=yat_clamp then{
            yat=yat_clamp;
            xat=round((yat_clamp-al)/ratio);
        }
       
    }else{
        xat=clamp(uiz_getmouse_x() + graboffx,x_min,x_max);
        yat=clamp(uiz_getmouse_y() + graboffy,y_min,y_max);
    }
    
    //get how much the mouse has moved
    switch (isresizing_y) {
        case uiz_top:
        pxmovedy=iy - yat ;
        break;
        case uiz_bottom:
        pxmovedy=ily - yat;
        break;
        }
    switch (isresizing_x) {
        case uiz_left:
        pxmovedx=ix - xat ;
        break;
        case uiz_right:
        pxmovedx=ilx - xat;
        break;
        }
        var ratio_abs=abs(ratio)
    //sdbm("mov",pxmovedy,graboffy,ily,yat,al,ap,ratio)
    //actually resize windows
    switch (isresizing_y) {
        case uiz_top:
            //top
            var oldheight = iheight
            iheight = max(iheight + pxmovedy , minh);
            break;
        case uiz_bottom:
            //bottom
            iheight = max(iheight - pxmovedy, minh);
            break;
    }
    switch (isresizing_x) {
        case uiz_left:
            //left
            var oldwidth = iwidth;
            iwidth = max(iwidth + pxmovedx, minw);
            break;
        case uiz_right:
            //right
            iwidth = max(iwidth - pxmovedx, minw);
            break;
    }
    //uiz_window_checkcontainment();
    if keepratio=true then{
    if isresizing_x=uiz_null then{
        iwidth = iheight/ratio_abs;
    }
    if isresizing_y=uiz_null then{
        iheight = iwidth*ratio_abs;
    }
    
    
        if abs((iheight/iwidth)-ratio_abs)&gt;0.001 then{
            //sdbm("[uiZ|ERROR]Ratio of window is not set correctly anymore. This is now reverted, but might cause some other issues.")
            iheight = round(min(iwidth*ratio_abs,iheight));
            iwidth = round(min(iheight/ratio_abs,iwidth));
        }
        
    }
    
    if isresizing_y=uiz_top then{
    //sdbm("changing y")
        y += oldheight - iheight;
    }
    if isresizing_x=uiz_left then{
        x += oldwidth - iwidth;
    }
    width=iwidth+end_leftframemargin+end_rightframemargin;
    height=iheight+end_topframemargin+end_bottomframemargin;
    if inanimation=true then{
    uiz_animation_capture_newstate(id);
    }
    //check for minimization
    if iwidth &lt;= 0 and iheight &lt;= 0 then {
        //minimum size
        sizestatus = 0;
    } else {
        //bigger than miminum size
        if sizestatus = 0 then {
            sizestatus = 1
        }
        if x&lt;=maximizesnapmargin and y&lt;=maximizesnapmargin and rlx &gt;= parent.ilx-maximizesnapmargin and rly &gt;= parent.ily-maximizesnapmargin then {
            //maximum size
            sizestatus = 2;
        } else {
            //smaller than maximum size
            if sizestatus = 2 then {
                sizestatus = 1;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle buttons and window movement
var fixforp = id;

if global.lockwindowresel = 0 and global.selectedwindow != id and global.mouseoverwindow = id and mouse_check_button(mb_left)/* and(sizestatus &lt; 2 or global.lastmousemoved &gt; 2 or snaptomouse = true) and isresizing = false */then {
    uiz_window_select(id);
}
var dorececkloverbut = false;
var customButtonSize = ds_list_size(custom_buttons_right_sprite);
var buttonssize = (button_cross + button_maximize + button_minimize + customButtonSize)
var frombuttons = ilx - bars * buttonssize
var inrange = uiz_range(uiz_getmouse_y(), ry, iy);
var inrange_last = uiz_range(uiz_getmouse_y_last(), ry, iy);


if kmouseover &gt; 0 and uiz_getmouse_y()&gt;=ry+doublemargins*topframemargin and uiz_getmouse_y()&lt;=iy-bkmar-doublemargins*bottomframemargin and uiz_getmouse_x() &gt; frombuttons and uiz_getmouse_x() &lt; ilx and inrange = true and global.mousefrozen = false and isresizing = 0 and snaptomouse = 0 then {
    checkbuttons = true;
    //mouse over button area
    overbut = floor((uiz_getmouse_x() - frombuttons) / bars);
    
    if loverbut_mouse != mouse_check_button(mb_left) then {
        dorececkloverbut = true;
    }
} else {
    overbut = -1;
}
if checkbuttons = false and isresizing = 0 and global.selectedwindow = id and mouse_check_button(mb_left) and(sizestatus &lt; 2 or global.lastmousemoved &gt; 2 or snaptomouse = 1) then {
    if snaptomouse = 0 and inanimation = 0 and global.mouseoverwindow = id and inrange_last = true then {
        snaptomouse = 1
        global.mousefrozen = true
        mouseminx = uiz_getmouse_x()
        mouseminy = uiz_getmouse_y()
        windowsminx = x;
        windowsminy = y
        posinframex = uiz_static
        posinframey = uiz_static
        if sizestatus = 2 then {
            an_old_posinframex = uiz_static
            an_old_posinframey = uiz_static
            uiz_window_unmaximize();
            windowsminx = uiz_getmouse_x() - (uiz_getmouse_x() / obj_uiZ_controller.width) * (an_old_width)
            fix = 2;
        }

    }
} else {
    if snaptomouse = 1 then {
        snaptomouse = 0;
        global.mousefrozen = false;
    }
}
var upd=false;
if (loverbut != overbut and((loverbut &gt;= 0 and loverbut &lt; buttonssize) or(overbut &gt;= 0 and overbut &lt; buttonssize))) {
    button_cross_state = 0;
    button_maximize_state = 0;
    button_minimize_state = 0;
    for(var i=0;i&lt;customButtonSize;++i){
        custom_buttons_right_state[| i]=0;
    }
    upd=true;


    switch (overbut-customButtonSize) {
        case 0:
            if button_minimize = true then {
                button_minimize_state = 1;
            } else {
                if button_maximize = true then {
                    button_maximize_state = 1;
                } else {
                    if button_cross = true then {
                        button_cross_state = 1;
                    }
                }
            }
            break;
        case 1:
            if button_maximize = true then {
                button_maximize_state = 1
            } else {
                if button_cross = true then {
                    button_cross_state = 1;
                }
            }
            break;
        case 2:
            if button_cross = true then {
                button_cross_state = 1;
            }
            break;
        default:
            var customButtonPosition = customButtonSize-overbut-1;
            if customButtonPosition&gt;=0 &amp;&amp; customButtonPosition&lt;customButtonSize then{
                custom_buttons_right_state[| customButtonPosition] = 1;
                
            }else{
                sdbm("[uiZ|Warning] window custom button ID ",customButtonPosition," not found for window ",id)
            }
            
            break;
    }
    loverbut_mouse = mouse_check_button(mb_left);
    loverbut = overbut;
}

for(var i=0;i&lt;customButtonSize;++i){
    if custom_buttons_right_state[| i]&gt;0 then{
        var ns=mouse_check_button(mb_left) + 1;
        if ns!=custom_buttons_right_state[| i] then{
            custom_buttons_right_state[| i] = ns;
            upd=true;
        }
        if mouse_check_button_released(mb_left) and script_exists(custom_buttons_right_script[| i]) then {
            script_execute(custom_buttons_right_script[| i],id,i);
        }
    }
}

if button_cross_state &gt; 0 then {
    var ns=mouse_check_button(mb_left) + 1;
    if ns!=button_cross_state then{
    button_cross_state = ns;
    upd=true;
    }
    if mouse_check_button_released(mb_left) then {
        uiz_destroyobject_animation(id, destroyxfunction, destroyyfunction, destroyafunction, destroyspeed)
    }
}
if button_maximize_state &gt; 0 then {
    var ns=mouse_check_button(mb_left) + 1;
    if ns!=button_maximize_state then{
    button_maximize_state = ns;
    upd=true;
    }
    if mouse_check_button_released(mb_left) then {
        uiz_window_switchmaximize()
    }
}
if button_minimize_state &gt; 0 then {
    var ns=mouse_check_button(mb_left) + 1;
    if ns!=button_minimize_state then{
    button_minimize_state = ns;
    upd=true;
    }
    if mouse_check_button_released(mb_left) then {
        uiz_window_switchminimize()
    }
}
if upd=true then{
    uiz_updater_FixViews_area(frombuttons,ry,ilx,iy);//REENABLE//
}
if snaptomouse = 1 then {
    x = windowsminx + (uiz_getmouse_x() - mouseminx)
    y = windowsminy + (uiz_getmouse_y() - mouseminy)
    uiz_window_checkcontainment();
    fix = true;
}
if fix &gt;= 1 then {
    uiz_fixwindowpos(fixforp);
    uiz_fixchildren(id, true)
}
lkmouseover = kmouseover;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if global.mouseoverwindow!=id then{
if kmouseover=0 then{
loverbut=-1;
if
button_cross_state!=0 or
button_maximize_state!=0 or
button_minimize_state!=0 then{
button_cross_state=0;
button_maximize_state=0;
button_minimize_state=0;
var buttonssize=(button_cross+button_maximize+button_minimize)
uiz_updater_FixViews_area(ilx-bars*buttonssize,ry,ilx,iy-1);//REENABLE//
}
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>uiz_compatibility_mouse_docheck_window();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if uiz_cntn(){

uiz_back()


//sdbm("sprite used:",sprite_get_name(bkspr))
if iwidth&gt;bars*(1+button_cross+button_maximize) and iheight&gt;=0 then{
if topbackuse&gt;-1 then{u=topbackuse}

var old_bkspr=bkspr;
var old_bkcol=bkcol;
var old_bkmar=bkmar;
var old_texas=texas;

bkspr=top_bkspr;
bkcol=top_bkcol;
bkmar=top_bkmar;
texas=top_texas;

var old_ix=ix;
var old_iy=iy;
var old_ilx=ilx;
var old_ily=ily;

var old_rx=rx;
var old_ry=ry;
var old_rlx=rlx;
var old_rly=rly;

//bars=uiz_getposy(barsize,barsizevaltype);
if topbarInside then{
    ily=iy-bkmar;
    rx=ix;
    iy-=bars+bkmar;
    ry=iy;
    rlx=ilx;
    rly=ry+bars;
}else{
    rly=iy;
    ily=iy-bkmar;
    iy=ry+bkmar;
}


if doublemargins=true then{
ix+=leftframemargin
ilx-=rightframemargin
iy+=topframemargin
ily-=bottomframemargin

rx+=leftframemargin
rlx-=rightframemargin
ry+=topframemargin
rly-=bottomframemargin
}

uiz_back()

bkspr=old_bkspr;
bkcol=old_bkcol;
bkmar=old_bkmar;
texas=old_texas;







//draw text

if font&gt;-1 then{draw_set_font(font)}
draw_set_color(windowtextcolor)
draw_set_alpha(alpha)
draw_set_valign(valign)
draw_set_halign(halign)
draw_text(ix+(ilx-ix)*(halign/2),iy+(ily-iy)*(valign/2),uiz_gettext_contained(windowtext,width-bars*(1+button_cross+button_maximize+button_minimize)))

if button_cross then{uiz_draw_spritebutton_state(ilx-bars,iy,ilx,ily,button_cross_color_normal,button_cross_color_over,button_cross_color_in,button_cross_sprite,1,button_cross_state)}
if button_maximize then{uiz_draw_spritebutton_state(ilx-bars*(1+button_cross),iy,ilx-bars*(button_cross),ily,button_maximize_color_normal,button_maximize_color_over,button_maximize_color_in,button_maximize_sprite,1,button_maximize_state)}
if button_minimize then{uiz_draw_spritebutton_state(ilx-bars*(1+button_cross+button_maximize),iy,ilx-bars*(button_cross+button_maximize),ily,button_minimize_color_normal,button_minimize_color_over,button_minimize_color_in,button_minimize_sprite,1,button_minimize_state)}

//draw custom buttons on the left
var leftButtons = ds_list_size(custom_buttons_left_sprite);
for(var i=0;i&lt;leftButtons;++i){
    uiz_draw_spritebutton_state(ix+bars*i,iy,ix+bars*(i+1),ily,custom_buttons_left_color_normal[|i],custom_buttons_left_color_over[|i],custom_buttons_left_color_in[|i],custom_buttons_left_sprite[|i],1,custom_buttons_left_state[|i])
}

//draw custom buttons on the right
var rightButtons = ds_list_size(custom_buttons_right_sprite);
var baseX = ilx-bars*(button_cross+button_maximize+button_minimize);
for(var i=0;i&lt;rightButtons;++i){
    uiz_draw_spritebutton_state(baseX-bars*(i+1),iy,baseX-bars*(i),ily,custom_buttons_right_color_normal[|i],custom_buttons_right_color_over[|i],custom_buttons_right_color_in[|i],custom_buttons_right_sprite[|i],1,custom_buttons_right_state[|i])
}

ix=old_ix;
iy=old_iy;
ilx=old_ilx;
ily=old_ily;

rx=old_rx;
ry=old_ry;
rlx=old_rlx;
rly=old_rly;
}
//*/
uiz_containend()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
